<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Business Cases ‚Äî VELORA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        :root {
            --bg: #050816;
            --bg-alt: #0b1220;
            --panel: #020617;
            --accent: #22c55e;
            --accent-soft: rgba(34, 197, 94, 0.12);
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --border-subtle: rgba(148, 163, 184, 0.32);
            --chip-bg: rgba(15, 23, 42, 0.95);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, #1f2937 0, #020617 45%, #000 100%);
            color: var(--text-main);
            min-height: 100vh;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        /* TOP NAVBAR */

        .top-nav {
            position: sticky;
            top: 0;
            z-index: 40;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid rgba(31, 41, 55, 0.9);
        }

        .top-nav-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 18px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-icon {
            width: 34px;
            height: 34px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e 45%, #16a34a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 16px;
            color: #020617;
        }

        .brand-text-main {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: 0.06em;
        }

        .brand-text-sub {
            font-size: 11px;
            color: var(--text-muted);
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 13px;
        }

        .nav-links a {
            opacity: 0.86;
        }

        .nav-links a:hover {
            opacity: 1;
            color: var(--accent);
        }

        .nav-chip {
            padding: 4px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.9);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-muted);
        }

        /* PAGE LAYOUT */

        .page-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: 22px 16px 40px;
            display: grid;
            grid-template-columns: 290px minmax(0, 1fr);
            gap: 22px;
        }

        @media (max-width: 900px) {
            .page-wrapper {
                grid-template-columns: 1fr;
            }
        }

        /* SIDEBAR */

        .sidebar {
            background: linear-gradient(145deg, #020617, #020617 40%, rgba(34, 197, 94, 0.12));
            border-radius: 24px;
            padding: 22px 18px 20px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: sticky;
            top: 72px;
            height: fit-content;
        }

        .profile-block {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: 20px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 22px;
            color: #020617;
        }

        .student-name {
            font-size: 19px;
            font-weight: 700;
        }

        .student-meta {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .sidebar-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .focus-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .tag {
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--chip-bg);
            border: 1px solid rgba(51, 65, 85, 0.9);
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
        }

        .stat-card {
            padding: 9px 9px 8px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.18), #020617 55%);
            border: 1px solid rgba(55, 65, 81, 0.9);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-value {
            margin-top: 3px;
            font-size: 17px;
            font-weight: 700;
        }

        .links-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
        }

        .links-list a span {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
        }

        .links-list a:hover {
            color: var(--accent);
        }

        /* MAIN CONTENT */

        .content {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }

        .page-header h1 {
            font-size: 24px;
            letter-spacing: 0.04em;
        }

        .page-subtag {
            font-size: 11px;
            padding: 5px 11px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        .section-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-muted);
        }

        /* CASE BLOCKS */

        .case {
            margin-top: 8px;
            border-radius: 22px;
            background: linear-gradient(150deg, #020617, #020617 55%, rgba(34, 197, 94, 0.12));
            border: 1px solid rgba(55, 65, 81, 0.95);
            padding: 16px 16px 14px;
        }

        .case + .case {
            margin-top: 14px;
        }

        .case-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-pill {
            padding: 3px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            background: rgba(15, 23, 42, 0.95);
        }

        .case-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .case-field {
            margin-top: 6px;
        }

        .case-field h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-field p {
            font-size: 13px;
            color: var(--text-main);
            line-height: 1.7;
        }

        .case-grid {
            margin-top: 10px;
            display: grid;
            grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
            gap: 10px;
        }

        @media (max-width: 800px) {
            .case-grid {
                grid-template-columns: 1fr;
            }
        }

        .info-card {
            border-radius: 16px;
            padding: 10px 12px 10px;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(37, 99, 235, 0.2);
        }

        .info-label-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 600;
        }

        .info-icon {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: var(--accent-soft);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .info-main {
            font-size: 13px;
            font-weight: 600;
        }

        .info-sub {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .code-block {
            margin-top: 10px;
            border-radius: 14px;
            background: #020617;
            border: 1px solid rgba(31, 41, 55, 0.95);
            padding: 10px 10px 8px;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .code-title {
            font-weight: 600;
        }

        .copy-btn {
            padding: 4px 9px;
            border-radius: 999px;
            border: none;
            font-size: 11px;
            cursor: pointer;
            background: linear-gradient(135deg, #22c55e, #4ade80);
            color: #020617;
        }

        pre {
            margin: 0;
            font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
            color: #e5e7eb;
        }

        footer {
            margin-top: 16px;
            font-size: 11px;
            color: var(--text-muted);
            text-align: right;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <!-- TOP NAVBAR -->
    <header class="top-nav">
        <div class="top-nav-inner">
            <div class="brand">
                <div class="brand-icon">CD</div>
                <div>
                    <div class="brand-text-main">CITY DESIGN</div>
                    <div class="brand-text-sub">DAA ‚Äî Design &amp; Analysis of Algorithms</div>
                </div>
            </div>
            <nav class="nav-links">
                <a href="index.html">Home</a>
                <a href="about.html">About</a>
                <a href="project.html">Project</a>
                <a href="Velora.html">City-Velora</a>
                <a href="Rakshita.html">Rakshita</a>
                <a href="satish.html">Satish</a>
                <a href="aditya.html">Aditya</a>
                <a href="omkar.html">Omkar</a>
                <a href="#">Collabz</a>
                <span class="nav-chip">DAA ‚Ä¢ Project</span>
            </nav>
        </div>
    </header>

    <div class="page-wrapper">
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="profile-block">
                <div class="avatar">OH</div>
                <div>
                    <div class="student-name">OMKAR HATTIKAL</div>
                    <div class="student-meta">
                        Roll No: 213 ‚Ä¢ Dept. of CSE<br>
                        SEMESTER ‚Ä¢ DESIGN ANALYSIS AND ALGORITHMS
                    </div>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Focus Areas</div>
                <div class="focus-tags">
                    <span class="tag">Algorithms</span>
                    <span class="tag">Trees</span>
                    <span class="tag">Sorting</span>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Project Snapshot</div>
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">Business Cases</div>
                        <div class="stat-value">15</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Algorithms</div>
                        <div class="stat-value">15+</div>
                    </div>
                </div>
            </div>

            <div>
    <div class="sidebar-title">Links</div>
    <div class="links-list">
        <a href="https://github.com/omkarhattikal11/daa-project" target="_blank">
            GitHub Repository
            <span>https://github.com/omkarhattikal11/daa-project</span>
        </a>
    </div>
</div>

        </aside>

        <!-- MAIN CONTENT -->
        <main class="content">
            <div class="page-header">
                <h1>Business Cases ‚Äî VELORA</h1>
                <div class="page-subtag">DAA ‚Ä¢ Project</div>
            </div>

            <div class="section-label" style="margin-top:10px;">Business Cases</div>

            <!-- ========== CASE 1 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 1</span>
                    <span class="case-pill"> Logistics & Supply Chain </span>
                </div>
                <div class="case-title">Industrial Transport Route Optimization</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Optimizes transport routes between factories and warehouses to reduce travel time and fuel cost.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Roads between locations have different travel times. The system finds the quickest route for each delivery by modeling the network as a weighted graph.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Dijkstra‚Äôs Algorithm</div>
                        <div class="info-sub">
                            It efficiently finds the shortest travel-time path in a weighted road network.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Industry, Innovation & Infrastructure</div>
                        <div class="info-sub">
                           Supports efficient logistics and reduces fuel waste.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Edge {
    int to;
    int w; // travel time or cost
};

vector&lt;vector&lt;Edge&gt;&gt; graph;

vector&lt;int&gt; dijkstra(int n, int src) {
    const int INF = 1e9;
    vector&lt;int&gt; dist(n, INF);
    dist[src] = 0;

    using P = pair&lt;int,int&gt;; // (dist, node)
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;

        for (auto &e : graph[u]) {
            int v = e.to;
            int nd = d + e.w;
            if (nd &lt; dist[v]) {
                dist[v] = nd;
                pq.push({nd, v});
            }
        }
    }
    return dist;
}

int main() {
    int n = 6; // number of locations (0..5)
    graph.assign(n, {});

    auto addRoad = [&](int u, int v, int w) {
        graph[u].push_back({v, w});
        graph[v].push_back({u, w}); // undirected road
    };

    // sample roads with travel time
    addRoad(0, 1, 4);
    addRoad(0, 2, 2);
    addRoad(1, 2, 1);
    addRoad(1, 3, 5);
    addRoad(2, 3, 8);
    addRoad(2, 4, 10);
    addRoad(3, 5, 2);
    addRoad(4, 5, 3);

    int source = 0; // factory
    vector&lt;int&gt; dist = dijkstra(n, source);

    cout &lt;&lt; "Minimum travel time from source " &lt;&lt; source &lt;&lt; ":\n";
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; "Location " &lt;&lt; i &lt;&lt; " : ";
        if (dist[i] == 1e9) cout &lt;&lt; "unreachable\n";
        else cout &lt;&lt; dist[i] &lt;&lt; " units\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 2 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 2</span>
                    <span class="case-pill">Urban Utilities & Environment</span>
                </div>
                <div class="case-title">Waste & Water Management Scheduling</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Schedules waste collection and water tanker dispatch based on urgency and deadlines.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Requests arrive with different priorities and deadlines. The system always processes the highest-priority, earliest-deadline task first.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Priority Queue (Min-Heap)</div>
                        <div class="info-sub">
                         It automatically keeps the most urgent request at the top for fast scheduling.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 6 ‚Äî Clean Water & Sanitation</div>
                        <div class="info-sub">
                           Ensures timely waste disposal and water supply.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Request {
    string id;
    int deadline; // smaller = earlier
    int priority; // higher = more important
};

struct Compare {
    bool operator()(const Request &amp;a, const Request &amp;b) const {
        if (a.deadline == b.deadline)
            return a.priority &lt; b.priority; // higher priority first
        return a.deadline &gt; b.deadline;     // earlier deadline first
    }
};

int main() {
    priority_queue&lt;Request, vector&lt;Request&gt;, Compare&gt; pq;

    // id, deadline (hour), priority
    pq.push({"Waste-Truck-A", 10, 2});
    pq.push({"Water-Tanker-1", 9, 1});
    pq.push({"Waste-Truck-B", 11, 3});
    pq.push({"Water-Tanker-2", 10, 5});

    cout &lt;&lt; "Service order (earliest &amp; highest priority first):\n";
    while (!pq.empty()) {
        Request r = pq.top(); pq.pop();
        cout &lt;&lt; "Request: " &lt;&lt; r.id 
             &lt;&lt; ", Deadline: " &lt;&lt; r.deadline
             &lt;&lt; ", Priority: " &lt;&lt; r.priority &lt;&lt; "\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 3 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 3</span>
                    <span class="case-pill"> Utility Monitoring & Maintenance </span>
                </div>
                <div class="case-title">Pipeline Network Fault Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Detects which pipeline sections stop receiving flow when a pipe fails.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The pipeline is a graph. When a connection breaks, BFS identifies which nodes are still reachable.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">BFS (Breadth-First Search)</div>
                        <div class="info-sub">
                           It quickly checks connectivity from the source to detect fault-affected areas.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Infrastructure</div>
                        <div class="info-sub">
                           Ensures reliable and safe pipeline systems.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; graph;

vector&lt;int&gt; bfs(int n, int src) {
    vector&lt;int&gt; visited(n, 0);
    queue&lt;int&gt; q;
    q.push(src);
    visited[src] = 1;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = 1;
                q.push(v);
            }
        }
    }
    return visited;
}

int main() {
    int n = 7;
    graph.assign(n, {});

    auto addPipe = [&](int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    };

    addPipe(0,1);
    addPipe(1,2);
    addPipe(2,3);
    addPipe(1,4);
    addPipe(4,5);
    addPipe(5,6);

    int faultyU = 1, faultyV = 4; // faulty pipe between 1 and 4

    // remove faulty edge logically by building a new graph
    vector&lt;vector&lt;int&gt;&gt; newGraph(n);
    for (int u = 0; u &lt; n; ++u) {
        for (int v : graph[u]) {
            if ((u == faultyU &amp;&amp; v == faultyV) ||
                (u == faultyV &amp;&amp; v == faultyU)) continue;
            newGraph[u].push_back(v);
        }
    }
    graph = newGraph;

    vector&lt;int&gt; reachable = bfs(n, 0); // source station 0

    cout &lt;&lt; "Nodes reachable from source after fault:\n";
    for (int i = 0; i &lt; n; ++i) {
        if (reachable[i]) cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " OK\n";
        else cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " affected by fault\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 4 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 4</span>
                    <span class="case-pill"> Intelligent Transportation Systems </span>
                </div>
                <div class="case-title">Highway Traffic Flow Optimization (NH-66)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Estimates fastest travel time between highway junctions considering congestion.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each segment has a base time + congestion value. The system computes the minimum-time path for vehicles.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Max-Heap / Priority Queue (Heapification)</div>
                        <div class="info-sub">
                            Each junction‚Äôs congestion level is stored in a max-heap. The algorithm repeatedly picks the highest-congestion intersections to adjust signal timings first, which matches the need to always handle the ‚Äúworst traffic‚Äù area in real time.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äî Sustainable Cities</div>
                        <div class="info-sub">
                           Reduces congestion and improves transport efficiency.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 4: Highway Traffic Flow Optimization (NH-66)
// Algorithm: Max-Heap Priority Queue (Handle highest congestion first)

#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Junction {
    string name;
    int congestion;  // number of vehicles / congestion score
};

// Max-heap comparator (higher congestion = higher priority)
struct Compare {
    bool operator()(const Junction &amp;a, const Junction &amp;b) {
        return a.congestion &lt; b.congestion;  
    }
};

int main() {
    priority_queue&lt;Junction, vector&lt;Junction&gt;, Compare&gt; pq;

    int n;
    cout &lt;&lt; "Enter number of highway junctions: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter junction name and congestion level:\n";
    for (int i = 0; i &lt; n; i++) {
        Junction j;
        cin &gt;&gt; j.name &gt;&gt; j.congestion;
        pq.push(j);
    }

    cout &lt;&lt; "\n--- Traffic Management Order (Highest Congestion First) ---\n";

    while (!pq.empty()) {
        Junction top = pq.top();
        pq.pop();

        cout &lt;&lt; "Junction: " &lt;&lt; top.name 
             &lt;&lt; " | Congestion Level: " &lt;&lt; top.congestion
             &lt;&lt; " \u2192 Adjust signal timing / open extra lane.\n";
    }

    cout &lt;&lt; "\nTraffic optimization cycle completed.\n";
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 5 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 5</span>
                    <span class="case-pill">Rail‚ÄìRoad Safety Management</span>
                </div>
                <div class="case-title">Railway Crossing Coordination</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Manages gates at multiple railway crossings where trains and road vehicles intersect. Goal is to minimise gate-closed time while maintaining full safety.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The system predicts when trains will reach the crossing and closes or opens the gate at the right moments, keeping it safe without unnecessary delays.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Event Scheduling with Priority Queue (Min-Heap by Arrival Time)</div>
                        <div class="info-sub">
                           A min-heap stores train events by arrival time, letting the system handle the earliest event first for safe, collision-free scheduling.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 ‚Äì Good Health and Well-Being; SDG 9 ‚Äì Industry, Innovation and Infrastructure</div>
                        <div class="info-sub">
                           Prevents accidents at railway crossings. Enhances safety of transport infrastructure.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 5 - Railway Crossing Coordination using Min-Heap Event Scheduling

#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Train {
    int arrivalTime;
    string trainName;
};

// Min-heap based on arrival times
struct CompareTrain {
    bool operator()(Train const&amp; a, Train const&amp; b) {
        return a.arrivalTime &gt; b.arrivalTime; // earlier train = higher priority
    }
};

int main() {
    priority_queue&lt;Train, vector&lt;Train&gt;, CompareTrain&gt; pq;

    int n;
    cout &lt;&lt; "Enter number of trains: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter train name and arrival time:\n";
    for (int i = 0; i &lt; n; i++) {
        Train t;
        cin &gt;&gt; t.trainName &gt;&gt; t.arrivalTime;
        pq.push(t);
    }

    cout &lt;&lt; "\n--- Railway Crossing Gate Schedule ---\n";
    while (!pq.empty()) {
        Train t = pq.top();
        pq.pop();
        cout &lt;&lt; "Train " &lt;&lt; t.trainName 
             &lt;&lt; " arriving at time " &lt;&lt; t.arrivalTime
             &lt;&lt; " \u2192 Gate CLOSED\n";
    }

    cout &lt;&lt; "\nAll trains processed safely.\n";
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 6 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 6</span>
                    <span class="case-pill"> Smart Storage & Security </span>
                </div>
                <div class="case-title">Smart Locker & Lost-and-Found System</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Visitors deposit items (bags, helmets, books, gadgets) in smart lockers or submit lost items at counters. The system must quickly store, search, and return items using a unique token or ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Items are stored with a unique token ID and basic details. The system lets staff quickly add items, find them by token, or mark them returned, with optional searches by type or color.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Hash Table (Hashing with unordered_map)</div>
                        <div class="info-sub">
                           Hashing gives near-instant (avg O(1)) insert and search by token ID, making item lookup extremely fast.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation &amp; Infrastructure; SDG 11 ‚Äì Sustainable Cities &amp; Communities</div>
                        <div class="info-sub">
                            Smart locker / digital tracking system improves visitor convenience and safety in a smart city park.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 6 - Smart Stall/Locker Lookup using Hashing (unordered_map)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct StallInfo {
    string name;
    string category;
    string location;
};

int main() {
    unordered_map&lt;int, StallInfo&gt; stalls; // key = stall ID
    int n;
    cout &lt;&lt; "Enter number of stalls: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter stallID, name, category, location:\n";
    for (int i = 0; i &lt; n; ++i) {
        int id;
        StallInfo s;
        cin &gt;&gt; id &gt;&gt; s.name &gt;&gt; s.category &gt;&gt; s.location;
        stalls[id] = s;
    }

    cout &lt;&lt; "\nEnter stall ID to search: ";
    int query;
    cin &gt;&gt; query;

    auto it = stalls.find(query);
    if (it != stalls.end()) {
        cout &lt;&lt; "Stall found:\n";
        cout &lt;&lt; "ID: " &lt;&lt; query &lt;&lt; "\n";
        cout &lt;&lt; "Name: " &lt;&lt; it-&gt;second.name &lt;&lt; "\n";
        cout &lt;&lt; "Category: " &lt;&lt; it-&gt;second.category &lt;&lt; "\n";
        cout &lt;&lt; "Location: " &lt;&lt; it-&gt;second.location &lt;&lt; "\n";
    } else {
        cout &lt;&lt; "Stall with ID " &lt;&lt; query &lt;&lt; " not found.\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 7 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 7</span>
                    <span class="case-pill">Information Retrieval & Search</span>
                </div>
                <div class="case-title">Fast Facility Lookup using a Trie</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Provides instant search for factories, warehouses and service centers by name or code. As the user types, suggestions appear in real time.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each facility has a unique name and ID stored in the system. When an operator types the first few characters, the system must quickly list all matching facilities without scanning the entire dataset, even when thousands of entries exist.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Trie (Prefix Tree) Data Structure</div>
                        <div class="info-sub">
                            Strings are stored character by character in a tree where each path represents a prefix. Looking up all names with a given prefix becomes O(length of prefix), which is ideal for fast auto-complete and search.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
Speeds up access to industrial information and services. Efficient lookups support smoother industrial operations.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

// ---------------- Trie Node ----------------
struct TrieNode {
    unordered_map&lt;char, TrieNode*&gt; next;
    vector&lt;int&gt; ids;   // Stores indices of facilities with this prefix
};

// ---------------- Facility Struct ----------------
struct Facility {
    string name;
    string id;
};

// ---------------- Trie Class ----------------
class Trie {
public:
    Trie() { root = new TrieNode(); }

    void insert(const string &amp;name, int idx) {
        TrieNode* node = root;
        for (char c : toLower(name)) {
            if (!node-&gt;next.count(c))
                node-&gt;next[c] = new TrieNode();
            node = node-&gt;next[c];
            node-&gt;ids.push_back(idx);
        }
    }

    vector&lt;int&gt; searchPrefix(const string &amp;prefix) {
        TrieNode* node = root;
        for (char c : toLower(prefix)) {
            if (!node-&gt;next.count(c)) return {};
            node = node-&gt;next[c];
        }
        return node-&gt;ids;
    }

private:
    TrieNode* root;

    string toLower(string s) {
        for (char &amp;c : s) c = tolower(c);
        return s;
    }
};

// ---------------- MAIN PROGRAM ----------------
int main() {
    Trie trie;
    vector&lt;Facility&gt; facilities;

    // Preloaded sample data
    vector&lt;pair&lt;string,string&gt;&gt; demo = {
        {"Alpha Factory", "F001"},
        {"Alpha Warehouse", "W010"},
        {"Beta Service Center", "S020"},
        {"Central Logistics Hub", "H100"},
        {"City West Depot", "D200"}
    };

    // Insert demo data into Trie
    for (auto &amp;p : demo) {
        facilities.push_back({p.first, p.second});
        trie.insert(p.first, facilities.size() - 1);
    }

    cout &lt;&lt; "\n--- Fast Facility Lookup Using Trie ---\n";

    while (true) {
        cout &lt;&lt; "\n1. Add Facility\n";
        cout &lt;&lt; "2. Search by Prefix\n";
        cout &lt;&lt; "3. Exit\n";
        cout &lt;&lt; "Choice: ";

        int ch;
        cin &gt;&gt; ch;
        cin.ignore();

        if (ch == 1) {
            Facility f;
            cout &lt;&lt; "Facility Name: ";
            getline(cin, f.name);
            cout &lt;&lt; "Facility ID: ";
            getline(cin, f.id);

            facilities.push_back(f);
            trie.insert(f.name, facilities.size() - 1);

            cout &lt;&lt; "Added successfully!\n";
        }
        else if (ch == 2) {
            string pref;
            cout &lt;&lt; "Enter prefix: ";
            getline(cin, pref);

            vector&lt;int&gt; result = trie.searchPrefix(pref);

            if (result.empty()) {
                cout &lt;&lt; "No facility found.\n";
            } else {
                cout &lt;&lt; "\nMatching Facilities:\n";
                for (int idx : result) {
                    cout &lt;&lt; " - " &lt;&lt; facilities[idx].name
                         &lt;&lt; " (ID: " &lt;&lt; facilities[idx].id &lt;&lt; ")\n";
                }
            }
        }
        else if (ch == 3) {
            cout &lt;&lt; "Goodbye!\n";
            break;
        }
        else {
            cout &lt;&lt; "Invalid option.\n";
        }
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 8 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 8</span>
                    <span class="case-pill">System Monitoring & Debugging</span>
                </div>
                <div class="case-title">Log Pattern Detection with Brute-Force String Match</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Searches small to medium-sized log files for specific error keywords or patterns. Used by operators during quick manual checks.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>When a fault is reported, engineers provide an error pattern (e.g., "CRITICAL_TIMEOUT"). The system scans recent log files to highlight every occurrence of this pattern so they can see when and where it happened, but log sizes are moderate so extreme optimisation is not mandatory.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Brute-Force Pattern Matching</div>
                        <div class="info-sub">
                          Compares the pattern with every possible position in the log string. The algorithm is simple to implement, easy to debug, and performs well enough for moderate-sized logs, making it suitable when development time is more critical than ultra-high speed.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Helps maintain reliable industrial IT systems. Reduces downtime and waste by fast fault diagnosis.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 8: Log Pattern Detection using Brute-Force Matching
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Brute-force pattern matching function
vector&lt;int&gt; findPattern(const string &amp;logData, const string &amp;pattern) {
    vector&lt;int&gt; positions;
    int n = logData.size();
    int m = pattern.size();

    for (int i = 0; i &lt;= n - m; i++) {
        int j = 0;
        // check pattern match starting at index i
        while (j &lt; m &amp;&amp; logData[i + j] == pattern[j]) {
            j++;
        }
        if (j == m) {
            positions.push_back(i); // pattern found at index i
        }
    }
    return positions;
}

int main() {
    string logData, pattern;

    cout &lt;&lt; "Enter log text (single line or long text):\n";
    getline(cin, logData);

    cout &lt;&lt; "Enter error pattern to search for: ";
    getline(cin, pattern);

    vector&lt;int&gt; result = findPattern(logData, pattern);

    if (result.empty()) {
        cout &lt;&lt; "\nPattern NOT FOUND in log.\n";
    } else {
        cout &lt;&lt; "\nPattern found at positions: ";
        for (int idx : result) {
            cout &lt;&lt; idx &lt;&lt; " ";
        }
        cout &lt;&lt; "\nTotal occurrences: " &lt;&lt; result.size() &lt;&lt; "\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 9 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 9</span>
                    <span class="case-pill">Large-Scale System Analytics</span>
                </div>
                <div class="case-title">Industrial Log Error Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Automatically scans huge log streams from multiple industrial machines to detect recurring error signatures. Needs to be faster and more scalable than simple brute-force search.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Production plants generate millions of log lines per day. The system maintains a set of known error patterns and must continuously check incoming logs to detect them quickly. Since logs are long, naive scanning for each pattern would be too slow.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Knuth‚ÄìMorris‚ÄìPratt (KMP) Pattern Matching</div>
                        <div class="info-sub">
                            KMP preprocesses the pattern to build a longest-prefix-suffix (LPS) table, allowing the search to avoid re-checking characters when a mismatch occurs. This gives linear-time matching in the size of the log, which is ideal for high-volume error detection.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Supports stable and resilient industrial automation. Early detection of faults prevents waste, defects and rework.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 9: Industrial Log Error Detection using KMP Algorithm
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Build LPS array (Longest Prefix which is also Suffix)
vector&lt;int&gt; buildLPS(const string &amp;pat) {
    int m = pat.size();
    vector&lt;int&gt; lps(m, 0);
    int len = 0; // length of previous longest prefix suffix

    for (int i = 1; i &lt; m; ) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

// KMP search function
vector&lt;int&gt; KMPSearch(const string &amp;text, const string &amp;pat) {
    vector&lt;int&gt; lps = buildLPS(pat);
    vector&lt;int&gt; positions;

    int n = text.size();
    int m = pat.size();
    int i = 0, j = 0; // text index, pattern index

    while (i &lt; n) {
        if (text[i] == pat[j]) {
            i++;
            j++;
        }
        if (j == m) {
            positions.push_back(i - j); // pattern found at index (i-j)
            j = lps[j - 1];
        } else if (i &lt; n &amp;&amp; text[i] != pat[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return positions;
}

int main() {
    string logData, pattern;

    cout &lt;&lt; "Enter log data (single line or multiple words):\n";
    getline(cin, logData);

    cout &lt;&lt; "Enter error pattern to detect: ";
    getline(cin, pattern);

    vector&lt;int&gt; result = KMPSearch(logData, pattern);

    if (result.empty()) {
        cout &lt;&lt; "\nPattern NOT FOUND in log.\n";
    } else {
        cout &lt;&lt; "\nPattern found at positions: ";
        for (int idx : result) cout &lt;&lt; idx &lt;&lt; " ";
        cout &lt;&lt; "\nTotal occurrences: " &lt;&lt; result.size() &lt;&lt; "\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 10 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 10</span>
                    <span class="case-pill"> Vendor Management </span>
                </div>
                <div class="case-title">Vendor Directory Search</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora maintains a directory of vendors/stalls sorted by ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>It needs fast insert &amp; search, but also keeps the tree height balanced even when many vendors are added.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">AVL Tree</div>
                        <div class="info-sub">
                            AVL tree is a self-balancing BST with O(log n) search, insert, and delete. It avoids skewed trees that make search slow.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
                         Quick vendor identification reduces delays in operations, supporting productive workflows and contributing to stronger economic performance.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 10 - Vendor Directory using AVL Tree
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Node {
    int key;            // e.g., vendor ID
    string name;
    Node *left, *right;
    int height;
    Node(int k, string n) : key(k), name(n), left(nullptr), right(nullptr), height(1) {}
};

int getHeight(Node* n) {
    return n ? n-&gt;height : 0;
}

int getBalance(Node* n) {
    return n ? getHeight(n-&gt;left) - getHeight(n-&gt;right) : 0;
}

Node* rightRotate(Node* y) {
    Node* x = y-&gt;left;
    Node* T2 = x-&gt;right;

    x-&gt;right = y;
    y-&gt;left = T2;

    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;
    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x-&gt;right;
    Node* T2 = y-&gt;left;

    y-&gt;left = x;
    x-&gt;right = T2;

    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;
    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;

    return y;
}

Node* insertNode(Node* node, int key, const string &amp;name) {
    if (!node) return new Node(key, name);

    if (key &lt; node-&gt;key)
        node-&gt;left = insertNode(node-&gt;left, key, name);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insertNode(node-&gt;right, key, name);
    else
        return node; // duplicate IDs not inserted

    node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));
    int balance = getBalance(node);

    // Left Left
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);
    // Right Right
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);
    // Left Right
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) {
        node-&gt;left = leftRotate(node-&gt;left);
        return rightRotate(node);
    }
    // Right Left
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    return node;
}

Node* search(Node* root, int key) {
    if (!root || root-&gt;key == key) return root;
    if (key &lt; root-&gt;key) return search(root-&gt;left, key);
    return search(root-&gt;right, key);
}

void inorder(Node* root) {
    if (!root) return;
    inorder(root-&gt;left);
    cout &lt;&lt; root-&gt;key &lt;&lt; " - " &lt;&lt; root-&gt;name &lt;&lt; "\n";
    inorder(root-&gt;right);
}

int main() {
    Node* root = nullptr;
    int n;
    cout &lt;&lt; "Enter number of vendors: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter vendorID and name:\n";
    for (int i = 0; i &lt; n; ++i) {
        int id;
        string name;
        cin &gt;&gt; id &gt;&gt; name;
        root = insertNode(root, id, name);
    }

    cout &lt;&lt; "\nVendors in sorted order (AVL inorder traversal):\n";
    inorder(root);

    cout &lt;&lt; "\nEnter vendorID to search: ";
    int q;
    cin &gt;&gt; q;
    Node* res = search(root, q);
    if (res) cout &lt;&lt; "Vendor found: " &lt;&lt; res-&gt;key &lt;&lt; " - " &lt;&lt; res-&gt;name &lt;&lt; "\n";
    else cout &lt;&lt; "Vendor not found.\n";

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 11 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 11</span>
                    <span class="case-pill"> Crowd Management </span>
                </div>
                <div class="case-title">Crowd Density Monitor (Segment Tree)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora divides a walking street into sections. Each section has a current crowd count.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>We need fast updates when more people enter/leave and fast range queries, like ‚Äúhow many people between section 3 and 8?‚Äù.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Segment Tree</div>
                        <div class="info-sub">
                          A segment tree supports range sum queries and point updates in O(log n), ideal for live crowd monitoring dashboards.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities and Communities</div>
                        <div class="info-sub">
                        Real-time crowd monitoring helps prevent overcrowding in public spaces, improving safety and supporting smarter urban management.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 11 - Crowd Density Monitor using Segment Tree (range sum)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct SegmentTree {
    int n;
    vector&lt;int&gt; tree;

    SegmentTree(int size) {
        n = size;
        tree.assign(4 * n, 0);
    }

    void build(vector&lt;int&gt; &amp;arr, int idx, int l, int r) {
        if (l == r) {
            tree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(arr, 2 * idx, l, mid);
        build(arr, 2 * idx + 1, mid + 1, r);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void build(vector&lt;int&gt; &amp;arr) {
        build(arr, 1, 0, n - 1);
    }

    void update(int idx, int l, int r, int pos, int val) {
        if (l == r) {
            tree[idx] = val;
            return;
        }
        int mid = (l + r) / 2;
        if (pos &lt;= mid) update(2 * idx, l, mid, pos, val);
        else update(2 * idx + 1, mid + 1, r, pos, val);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void update(int pos, int val) {
        update(1, 0, n - 1, pos, val);
    }

    int query(int idx, int l, int r, int ql, int qr) {
        if (qr &lt; l || ql &gt; r) return 0;         // no overlap
        if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[idx]; // complete overlap
        int mid = (l + r) / 2;
        return query(2 * idx, l, mid, ql, qr) +
               query(2 * idx + 1, mid + 1, r, ql, qr);
    }

    int query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
};

int main() {
    int n;
    cout &lt;&lt; "Enter number of sections in street: ";
    cin &gt;&gt; n;

    vector&lt;int&gt; crowd(n);
    cout &lt;&lt; "Enter initial crowd count for each section:\n";
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; crowd[i];

    SegmentTree st(n);
    st.build(crowd);

    while (true) {
        cout &lt;&lt; "\n1. Update crowd at a section\n";
        cout &lt;&lt; "2. Query total crowd in a range\n";
        cout &lt;&lt; "3. Exit\n";
        cout &lt;&lt; "Choose option: ";
        int choice;
        cin &gt;&gt; choice;

        if (choice == 1) {
            int pos, val;
            cout &lt;&lt; "Enter section index (0-based) and new crowd count: ";
            cin &gt;&gt; pos &gt;&gt; val;
            st.update(pos, val);
        } else if (choice == 2) {
            int l, r;
            cout &lt;&lt; "Enter range [l r]: ";
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; "Total crowd from section " &lt;&lt; l &lt;&lt; " to " &lt;&lt; r
                 &lt;&lt; " = " &lt;&lt; st.query(l, r) &lt;&lt; "\n";
        } else {
            break;
        }
    }

    return 0;
}</pre>
                </div>
            </section>
            <!-- ========== CASE 12 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 12</span>
                    <span class="case-pill"> Research library & digital knowledge center</span>
                </div>
                <div class="case-title">Velora Knowledge Hub Search</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora‚Äôs Knowledge Hub is a central library where students and visitors search for books, research papers, and digital content. The system must quickly locate resources even when thousands of entries are stored.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Every resource (book, paper, video) is stored with a unique ID, title, and short abstract. Users can search by title or by keyword. The system first locates the right resource by title, then highlights where the keyword appears inside the abstract/description.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">AVL Tree + Boyer‚ÄìMoore</div>
                        <div class="info-sub">
                         AVL keeps the search tree balanced, so searching, inserting, or deleting any resource takes O(log n) time even when the library grows large.Boyer‚ÄìMoore is efficient for pattern matching in text, as it skips multiple characters at once, making keyword search inside long descriptions fast.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 4 ‚Äì Quality Education</div>
                        <div class="info-sub">
                       Faster access to knowledge and research material supports better learning and education.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> #include <bits/stdc++.h>
using namespace std;

struct AVLNode {
    string key;          // e.g. book or resource title
    int height;
    AVLNode *left;
    AVLNode *right;

    AVLNode(const string &k)
        : key(k), height(1), left(nullptr), right(nullptr) {}
};

int getHeight(AVLNode *node) {
    return node ? node->height : 0;
}

int getBalance(AVLNode *node) {
    if (!node) return 0;
    return getHeight(node->left) - getHeight(node->right);
}

AVLNode* rotateRight(AVLNode *y) {
    AVLNode *x = y->left;
    AVLNode *T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x; // new root
}

AVLNode* rotateLeft(AVLNode *x) {
    AVLNode *y = x->right;
    AVLNode *T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y; // new root
}

AVLNode* insertNode(AVLNode *node, const string &key) {
    // 1. Normal BST insertion
    if (!node) return new AVLNode(key);

    if (key < node->key)
        node->left = insertNode(node->left, key);
    else if (key > node->key)
        node->right = insertNode(node->right, key);
    else
        return node; // duplicate titles ignored or handle separately

    // 2. Update height
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    // 3. Get balance factor
    int balance = getBalance(node);

    // 4. Balance the tree

    // Left Left Case
    if (balance > 1 && key < node->left->key)
        return rotateRight(node);

    // Right Right Case
    if (balance < -1 && key > node->right->key)
        return rotateLeft(node);

    // Left Right Case
    if (balance > 1 && key > node->left->key) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    // Right Left Case
    if (balance < -1 && key < node->right->key) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    // already balanced
    return node;
}

// Simple search for exact title
bool searchTitle(AVLNode *root, const string &key) {
    if (!root) return false;
    if (key == root->key) return true;
    if (key < root->key) return searchTitle(root->left, key);
    return searchTitle(root->right, key);
}

// Example usage
int main() {
    AVLNode *root = nullptr;

    // Insert some resource titles
    root = insertNode(root, "Smart Parking in Velora");
    root = insertNode(root, "Green Energy Management");
    root = insertNode(root, "Waste Collection Optimization");
    root = insertNode(root, "Transit Scheduling in Velora");

    string query;
    cout << "Enter title to search: ";
    getline(cin, query);

    if (searchTitle(root, query))
        cout << "Resource found in Knowledge Hub.\n";
    else
        cout << "Resource not found.\n";

    return 0;
}
 </pre>
                </div>
            </section>
            <!-- ========== CASE 13 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 13</span>
                    <span class="case-pill"> Public transport inside Velora</span>
                </div>
                <div class="case-title">Velora Shuttle Fare & Route Planner</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora runs internal shuttle buses between different zones (hostels, labs, exhibitions, parking areas). The system must suggest cheap and safe routes for passengers and also handle special discounts or penalties on certain routes.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each stop in Velora is a node, and every road between stops has a cost (time, fare, or fuel usage). Sometimes some routes have discounts (negative cost edges, like ‚Äúearly morning discount‚Äù) or additional penalties (like ‚Äútemporary congestion charge‚Äù). The planner needs to compute the best route from a given source stop to all other stops considering these adjustments.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Bellman‚ÄìFord + Segment Tree + Floyd‚ÄìWarshall </div>
                        <div class="info-sub">
                       Bellman‚ÄìFord : Used for single-source shortest path where edges can have negative weights.Segment Tree : Used to manage and update fare or crowd levels over time ranges efficiently. Floyd‚ÄìWarshall : Used if Velora wants an all-pairs distance matrix between all stops, so at any time you can look up the best route between any two zones directly. 
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities and Communities</div>
                        <div class="info-sub">
                      Better public transit planning reduces congestion and supports eco-friendly mobility.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> #include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v;
    int w; // cost: time / fare (can be negative for discount)
};

int main() {
    int n, m, src;
    cout << "Enter number of stops (vertices): ";
    cin >> n;
    cout << "Enter number of roads (edges): ";
    cin >> m;

    vector<Edge> edges(m);

    cout << "Enter edges as: from to cost\n";
    for (int i = 0; i < m; ++i) {
        cin >> edges[i].u >> edges[i].v >> edges[i].w;
    }

    cout << "Enter source stop: ";
    cin >> src;

    const int INF = 1e9;
    vector<int> dist(n + 1, INF);
    dist[src] = 0;

    // Relax edges (n - 1) times
    for (int i = 1; i <= n - 1; ++i) {
        bool changed = false;
        for (const auto &e : edges) {
            if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
                dist[e.v] = dist[e.u] + e.w;
                changed = true;
            }
        }
        if (!changed) break; // no change => already optimal
    }

    // Check for negative-weight cycle
    bool hasNegativeCycle = false;
    for (const auto &e : edges) {
        if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
            hasNegativeCycle = true;
            break;
        }
    }

    if (hasNegativeCycle) {
        cout << "Warning: Negative cycle detected in Velora shuttle network!\n";
    } else {
        cout << "Shortest cost from stop " << src << " to others:\n";
        for (int i = 1; i <= n; ++i) {
            cout << "Stop " << i << ": ";
            if (dist[i] == INF) cout << "unreachable\n";
            else cout << dist[i] << "\n";
        }
    }

    return 0;
} </pre>
                </div>
            </section>
  <!-- ========== CASE 14 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 14</span>
                    <span class="case-pill"> Logistics & Supply Chain </span>
                </div>
                <div class="case-title">Emergency Vehicle Dispatch Sorting</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora‚Äôs emergency control room receives multiple distress calls with different severity scores. They must be arranged in correct order so ambulances or fire units are dispatched efficiently.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each call has a severity value (1‚Äì10). To plan dispatch order, the system sorts all active calls from highest severity to lowest before allocating rescue units.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Merge Sort</div>
                        <div class="info-sub">
                           Merge Sort gives O(n log n) performance and remains fast even for large lists of emergency calls. It is stable and predictable, ensuring emergencies are ranked accurately.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 ‚Äì Good Health and Well-Being, SDG 11 ‚Äì Sustainable Cities</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // CASE 12: Emergency Vehicle Dispatch Sorting using Merge Sort
#include <bits/stdc++.h>
using namespace std;

struct Call {
    string id;
    int severity;
};

void mergeArr(vector<Call> &arr, int l, int m, int r) {
    vector<Call> left(arr.begin() + l, arr.begin() + m + 1);
    vector<Call> right(arr.begin() + m + 1, arr.begin() + r + 1);

    int i = 0, j = 0, k = l;

    while (i < left.size() && j < right.size()) {
        // Sort by severity (high ‚Üí low)
        if (left[i].severity >= right[j].severity)
            arr[k++] = left[i++];
        else
            arr[k++] = right[j++];
    }
    while (i < left.size()) arr[k++] = left[i++];
    while (j < right.size()) arr[k++] = right[j++];
}

void mergeSort(vector<Call> &arr, int l, int r) {
    if (l >= r) return;
    int m = (l + r) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    mergeArr(arr, l, m, r);
}

int main() {
    int n;
    cout << "Enter number of emergency calls: ";
    cin >> n;

    vector<Call> calls(n);
    cout << "Enter CallID and Severity:\n";
    for (int i = 0; i < n; i++)
        cin >> calls[i].id >> calls[i].severity;

    mergeSort(calls, 0, n - 1);

    cout << "\nDispatch Order (Highest Severity First):\n";
    for (auto &c : calls)
        cout << c.id << " - Severity " << c.severity << "\n";

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 15 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 15</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Shuttle Boarding Reorder</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>boarding queue for shuttles.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Mostly near-sorted because passengers generally queue in arrival order but occasionally VIPs or reorders appear. The system must quickly reorder a small portion (fast incremental updates) and occasionally fully re-sort the list.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Quick + Selection + Bubble</div>
                        <div class="info-sub">
                          Quick Sort ‚Üí for fast large-size ordering (peak hours)

Selection Sort ‚Üí when exact position-based comparison is needed

Bubble Sort ‚Üí for minor adjustments (few misplaced passengers)
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities & Communities, SDG 11 ‚Äì Sustainable Cities & Communities, SDG 8 ‚Äì Decent Work & Economic Growth</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // Case B: Shuttle Boarding Reorder (QuickSort primary; Selection for top-k promotions; Bubble for tiny local fixes)
#include <bits/stdc++.h>
using namespace std;

struct Passenger {
    string id;
    int vipScore;   // higher = more priority to board
    long long arrival; // arrival timestamp
};

// comparator: VIP first (desc), then earlier arrival
bool cmpPassenger(const Passenger &a, const Passenger &b) {
    if (a.vipScore != b.vipScore) return a.vipScore > b.vipScore;
    return a.arrival < b.arrival;
}

// --- QuickSort (in-place) ---
int partitionQuick(vector<Passenger> &arr, int l, int r) {
    Passenger pivot = arr[r];
    int i = l - 1;
    for (int j = l; j < r; ++j) {
        if (cmpPassenger(arr[j], pivot)) {
            ++i; swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[r]);
    return i + 1;
}

void quickSort(vector<Passenger> &arr, int l, int r) {
    if (l >= r) return;
    int pi = partitionQuick(arr, l, r);
    quickSort(arr, l, pi - 1);
    quickSort(arr, pi + 1, r);
}

// --- Selection to promote top-k VIP into front (stable extraction using simple scan) ---
void promoteTopK(vector<Passenger> &arr, int k) {
    if (k <= 0) return;
    int n = arr.size();
    k = min(k, n);
    // selection-like: for i in [0..k-1], find best in [i..n-1] and bring to i
    for (int i = 0; i < k; ++i) {
        int best = i;
        for (int j = i + 1; j < n; ++j) {
            if (cmpPassenger(arr[j], arr[best])) best = j;
        }
        // rotate to keep relative order for others (stable-ish)
        Passenger temp = arr[best];
        for (int t = best; t > i; --t) arr[t] = arr[t - 1];
        arr[i] = temp;
    }
}

// --- Tiny bubble pass to fix local small disorder (for near-sorted updates) ---
void tinyBubbleFix(vector<Passenger> &arr, int maxPasses = 2) {
    int n = arr.size();
    for (int pass = 0; pass < maxPasses; ++pass) {
        bool swapped = false;
        for (int i = 0; i + 1 < n; ++i) {
            if (!cmpPassenger(arr[i], arr[i + 1])) {
                swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cout << "Enter number of passengers in queue: ";
    if (!(cin >> n) || n <= 0) return 0;

    vector<Passenger> q;
    q.reserve(n);
    for (int i = 0; i < n; ++i) {
        Passenger p;
        cin >> p.id >> p.vipScore >> p.arrival; // e.g.: P123 5 1672531200
        q.push_back(p);
    }

    cout << "\nOptions:\n1) Tiny local fix (bubble)\n2) Promote top-k VIPs\n3) Full reorder (QuickSort)\n4) Print queue\n5) Exit\n";

    while (true) {
        cout << "\nChoice: ";
        int ch; cin >> ch;
        if (ch == 1) {
            tinyBubbleFix(q, 2);
            cout << "Applied tiny bubble fix.\n";
        } else if (ch == 2) {
            int k; cout << "Enter k (number to promote): "; cin >> k;
            promoteTopK(q, k);
            cout << "Promoted top-" << k << " VIPs to front.\n";
        } else if (ch == 3) {
            quickSort(q, 0, (int)q.size() - 1);
            cout << "Full reorder done with QuickSort.\n";
        } else if (ch == 4) {
            cout << "\nCurrent queue order:\n";
            for (int i = 0; i < (int)q.size(); ++i) {
                cout << i + 1 << ". " << q[i].id
                     << " (vip=" << q[i].vipScore
                     << ", arrival=" << q[i].arrival << ")\n";
            }
        } else if (ch == 5) break;
        else cout << "Invalid.\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <footer>
                KLE TECHNOLOGICAL UNIVERSITY ‚Ä¢ DAA Project 
            </footer>
        </main>
    </div>

    <!-- COPY CODE SCRIPT -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const buttons = document.querySelectorAll('.copy-btn');

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const codeBlock = btn.closest('.code-block');
                    if (!codeBlock) return;
                    const pre = codeBlock.querySelector('pre');
                    if (!pre) return;

                    const text = pre.innerText;

                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            const oldText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = oldText;
                            }, 1200);
                        }).catch(() => {
                            alert('Copy failed. Please copy manually.');
                        });
                    } else {
                        // Fallback for very old browsers
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        document.body.appendChild(textarea);
                        textarea.select();
                        try {
                            document.execCommand('copy');
                            const oldText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = oldText;
                            }, 1200);
                        } catch (e) {
                            alert('Copy failed. Please copy manually.');
                        }
                        document.body.removeChild(textarea);
                    }
                });
            });
        });
    </script>
</body>
</html>
