<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Business Cases ‚Äî VELORA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        :root {
            --bg: #050816;
            --bg-alt: #0b1220;
            --panel: #020617;
            --accent: #22c55e;
            --accent-soft: rgba(34, 197, 94, 0.12);
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --border-subtle: rgba(148, 163, 184, 0.32);
            --chip-bg: rgba(15, 23, 42, 0.95);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, #1f2937 0, #020617 45%, #000 100%);
            color: var(--text-main);
            min-height: 100vh;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        /* TOP NAVBAR */

        .top-nav {
            position: sticky;
            top: 0;
            z-index: 40;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid rgba(31, 41, 55, 0.9);
        }

        .top-nav-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 18px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-icon {
            width: 34px;
            height: 34px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e 45%, #16a34a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 16px;
            color: #020617;
        }

        .brand-text-main {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: 0.06em;
        }

        .brand-text-sub {
            font-size: 11px;
            color: var(--text-muted);
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 13px;
        }

        .nav-links a {
            opacity: 0.86;
        }

        .nav-links a:hover {
            opacity: 1;
            color: var(--accent);
        }

        .nav-chip {
            padding: 4px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.9);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-muted);
        }

        /* PAGE LAYOUT */

        .page-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: 22px 16px 40px;
            display: grid;
            grid-template-columns: 290px minmax(0, 1fr);
            gap: 22px;
        }

        @media (max-width: 900px) {
            .page-wrapper {
                grid-template-columns: 1fr;
            }
        }

        /* SIDEBAR */

        .sidebar {
            background: linear-gradient(145deg, #020617, #020617 40%, rgba(34, 197, 94, 0.12));
            border-radius: 24px;
            padding: 22px 18px 20px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: sticky;
            top: 72px;
            height: fit-content;
        }

        .profile-block {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: 20px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 22px;
            color: #020617;
        }

        .student-name {
            font-size: 19px;
            font-weight: 700;
        }

        .student-meta {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .sidebar-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .focus-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .tag {
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--chip-bg);
            border: 1px solid rgba(51, 65, 85, 0.9);
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
        }

        .stat-card {
            padding: 9px 9px 8px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.18), #020617 55%);
            border: 1px solid rgba(55, 65, 81, 0.9);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-value {
            margin-top: 3px;
            font-size: 17px;
            font-weight: 700;
        }

        .links-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
        }

        .links-list a span {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
        }

        .links-list a:hover {
            color: var(--accent);
        }

        /* MAIN CONTENT */

        .content {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }

        .page-header h1 {
            font-size: 24px;
            letter-spacing: 0.04em;
        }

        .page-subtag {
            font-size: 11px;
            padding: 5px 11px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        .section-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-muted);
        }

        /* CASE BLOCKS */

        .case {
            margin-top: 8px;
            border-radius: 22px;
            background: linear-gradient(150deg, #020617, #020617 55%, rgba(34, 197, 94, 0.12));
            border: 1px solid rgba(55, 65, 81, 0.95);
            padding: 16px 16px 14px;
        }

        .case + .case {
            margin-top: 14px;
        }

        .case-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-pill {
            padding: 3px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            background: rgba(15, 23, 42, 0.95);
        }

        .case-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .case-field {
            margin-top: 6px;
        }

        .case-field h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-field p {
            font-size: 13px;
            color: var(--text-main);
            line-height: 1.7;
        }

        .case-grid {
            margin-top: 10px;
            display: grid;
            grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
            gap: 10px;
        }

        @media (max-width: 800px) {
            .case-grid {
                grid-template-columns: 1fr;
            }
        }

        .info-card {
            border-radius: 16px;
            padding: 10px 12px 10px;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(37, 99, 235, 0.2);
        }

        .info-label-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 600;
        }

        .info-icon {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: var(--accent-soft);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .info-main {
            font-size: 13px;
            font-weight: 600;
        }

        .info-sub {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .code-block {
            margin-top: 10px;
            border-radius: 14px;
            background: #020617;
            border: 1px solid rgba(31, 41, 55, 0.95);
            padding: 10px 10px 8px;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .code-title {
            font-weight: 600;
        }

        .copy-btn {
            padding: 4px 9px;
            border-radius: 999px;
            border: none;
            font-size: 11px;
            cursor: pointer;
            background: linear-gradient(135deg, #22c55e, #4ade80);
            color: #020617;
        }

        pre {
            margin: 0;
            font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
            color: #e5e7eb;
        }

        footer {
            margin-top: 16px;
            font-size: 11px;
            color: var(--text-muted);
            text-align: right;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <!-- TOP NAVBAR -->
    <header class="top-nav">
        <div class="top-nav-inner">
            <div class="brand">
                <div class="brand-icon">CD</div>
                <div>
                    <div class="brand-text-main">CITY DESIGN</div>
                    <div class="brand-text-sub">DAA ‚Äî Design &amp; Analysis of Algorithms</div>
                </div>
            </div>
            <nav class="nav-links">
                <a href="index.html">Home</a>
                <a href="about.html">About</a>
                <a href="project.html">Project</a>
                <a href="Velora.html">City-Velora</a>
                <a href="Rakshita.html">Rakshita</a>
                <a href="satish.html">Satish</a>
                <a href="aditya.html">Aditya</a>
                <a href="omkar.html">Omkar</a>
                <a href="#">Collabz</a>
                <span class="nav-chip">DAA ‚Ä¢ Project</span>
            </nav>
        </div>
    </header>

    <div class="page-wrapper">
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="profile-block">
                <div class="avatar">OH</div>
                <div>
                    <div class="student-name">OMKAR HATTIKAL</div>
                    <div class="student-meta">
                        Roll No: 213 ‚Ä¢ Dept. of CSE<br>
                        SEMESTER ‚Ä¢ DESIGN ANALYSIS AND ALGORITHMS
                    </div>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Focus Areas</div>
                <div class="focus-tags">
                    <span class="tag">Algorithms</span>
                    <span class="tag">Trees</span>
                    <span class="tag">Sorting</span>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Project Snapshot</div>
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">Business Cases</div>
                        <div class="stat-value">10</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Core Algorithms</div>
                        <div class="stat-value">X+</div>
                    </div>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Links</div>
                <div class="links-list">
                    <a href="YOUR_GITHUB_LINK" target="_blank">
                        GitHub Repository
                        <span>omkarhattikal11</span>
                    </a>
                </div>
            </div>
        </aside>

        <!-- MAIN CONTENT -->
        <main class="content">
            <div class="page-header">
                <h1>Business Cases ‚Äî VELORA</h1>
                <div class="page-subtag">DAA ‚Ä¢ Project</div>
            </div>

            <div class="section-label" style="margin-top:10px;">Business Cases</div>

            <!-- ========== CASE 1 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 1</span>
                    <span class="case-pill"> Logistics & Supply Chain </span>
                </div>
                <div class="case-title">Industrial Transport Route Optimization</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Optimizes transport routes between factories and warehouses to reduce travel time and fuel cost.</p>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Roads between locations have different travel times. The system finds the quickest route for each delivery by modeling the network as a weighted graph.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Dijkstra‚Äôs Algorithm</div>
                        <div class="info-sub">
                            It efficiently finds the shortest travel-time path in a weighted road network.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Industry, Innovation & Infrastructure</div>
                        <div class="info-sub">
                           Supports efficient logistics and reduces fuel waste.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int to;
    int w; // travel time or cost
};

vector<vector<Edge>> graph;

vector<int> dijkstra(int n, int src) {
    const int INF = 1e9;
    vector<int> dist(n, INF);
    dist[src] = 0;

    using P = pair<int,int>; // (dist, node)
    priority_queue<P, vector<P>, greater<P>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;

        for (auto &e : graph[u]) {
            int v = e.to;
            int nd = d + e.w;
            if (nd < dist[v]) {
                dist[v] = nd;
                pq.push({nd, v});
            }
        }
    }
    return dist;
}

int main() {
    int n = 6; // number of locations (0..5)
    graph.assign(n, {});

    auto addRoad = [&](int u, int v, int w) {
        graph[u].push_back({v, w});
        graph[v].push_back({u, w}); // undirected road
    };

    // sample roads with travel time
    addRoad(0, 1, 4);
    addRoad(0, 2, 2);
    addRoad(1, 2, 1);
    addRoad(1, 3, 5);
    addRoad(2, 3, 8);
    addRoad(2, 4, 10);
    addRoad(3, 5, 2);
    addRoad(4, 5, 3);

    int source = 0; // factory
    vector<int> dist = dijkstra(n, source);

    cout << "Minimum travel time from source " << source << ":\n";
    for (int i = 0; i < n; ++i) {
        cout << "Location " << i << " : ";
        if (dist[i] == 1e9) cout << "unreachable\n";
        else cout << dist[i] << " units\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 2 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 2</span>
                    <span class="case-pill">Urban Utilities & Environment</span>
                </div>
                <div class="case-title">Waste & Water Management Scheduling</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Schedules waste collection and water tanker dispatch based on urgency and deadlines.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Requests arrive with different priorities and deadlines. The system always processes the highest-priority, earliest-deadline task first.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Priority Queue (Min-Heap)</div>
                        <div class="info-sub">
                         It automatically keeps the most urgent request at the top for fast scheduling.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main"SDG 6 ‚Äî Clean Water & Sanitation</div>
                        <div class="info-sub">
                           Ensures timely waste disposal and water supply.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>#include <bits/stdc++.h>
using namespace std;

struct Request {
    string id;
    int deadline; // smaller = earlier
    int priority; // higher = more important
};

struct Compare {
    bool operator()(const Request &a, const Request &b) const {
        if (a.deadline == b.deadline)
            return a.priority < b.priority; // higher priority first
        return a.deadline > b.deadline;     // earlier deadline first
    }
};

int main() {
    priority_queue<Request, vector<Request>, Compare> pq;

    // id, deadline (hour), priority
    pq.push({"Waste-Truck-A", 10, 2});
    pq.push({"Water-Tanker-1", 9, 1});
    pq.push({"Waste-Truck-B", 11, 3});
    pq.push({"Water-Tanker-2", 10, 5});

    cout << "Service order (earliest & highest priority first):\n";
    while (!pq.empty()) {
        Request r = pq.top(); pq.pop();
        cout << "Request: " << r.id 
             << ", Deadline: " << r.deadline
             << ", Priority: " << r.priority << "\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 3 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 3</span>
                    <span class="case-pill"> Utility Monitoring & Maintenance </span>
                </div>
                <div class="case-title">Pipeline Network Fault Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Detects which pipeline sections stop receiving flow when a pipe fails.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The pipeline is a graph. When a connection breaks, BFS identifies which nodes are still reachable.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">BFS (Breadth-First Search)</div>
                        <div class="info-sub">
                           It quickly checks connectivity from the source to detect fault-affected areas.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Infrastructure</div>
                        <div class="info-sub">
                           Ensures reliable and safe pipeline systems.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> graph;

vector<int> bfs(int n, int src) {
    vector<int> visited(n, 0);
    queue<int> q;
    q.push(src);
    visited[src] = 1;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = 1;
                q.push(v);
            }
        }
    }
    return visited;
}

int main() {
    int n = 7;
    graph.assign(n, {});

    auto addPipe = [&](int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    };

    addPipe(0,1);
    addPipe(1,2);
    addPipe(2,3);
    addPipe(1,4);
    addPipe(4,5);
    addPipe(5,6);

    int faultyU = 1, faultyV = 4; // faulty pipe between 1 and 4

    // remove faulty edge logically by building a new graph
    vector<vector<int>> newGraph(n);
    for (int u = 0; u < n; ++u) {
        for (int v : graph[u]) {
            if ((u == faultyU && v == faultyV) ||
                (u == faultyV && v == faultyU)) continue;
            newGraph[u].push_back(v);
        }
    }
    graph = newGraph;

    vector<int> reachable = bfs(n, 0); // source station 0

    cout << "Nodes reachable from source after fault:\n";
    for (int i = 0; i < n; ++i) {
        if (reachable[i]) cout << "Node " << i << " OK\n";
        else cout << "Node " << i << " affected by fault\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 4 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 4</span>
                    <span class="case-pill"> Intelligent Transportation Systems </span>
                </div>
                <div class="case-title">Highway Traffic Flow Optimization (NH-66)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Estimates fastest travel time between highway junctions considering congestion.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each segment has a base time + congestion value. The system computes the minimum-time path for vehicles.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Max-Heap / Priority Queue (Heapification)</div>
                        <div class="info-sub">
                            Each junction‚Äôs congestion level is stored in a max-heap. The algorithm repeatedly picks the highest-congestion intersections to adjust signal timings first, which matches the need to always handle the ‚Äúworst traffic‚Äù area in real time.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äî Sustainable Cities</div>
                        <div class="info-sub">
                           Reduces congestion and improves transport efficiency.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre> // CASE 4: Highway Traffic Flow Optimization (NH-66)
// Algorithm: Max-Heap Priority Queue (Handle highest congestion first)

#include <bits/stdc++.h>
using namespace std;

struct Junction {
    string name;
    int congestion;  // number of vehicles / congestion score
};

// Max-heap comparator (higher congestion = higher priority)
struct Compare {
    bool operator()(const Junction &a, const Junction &b) {
        return a.congestion < b.congestion;  
    }
};

int main() {
    priority_queue<Junction, vector<Junction>, Compare> pq;

    int n;
    cout << "Enter number of highway junctions: ";
    cin >> n;

    cout << "Enter junction name and congestion level:\n";
    for (int i = 0; i < n; i++) {
        Junction j;
        cin >> j.name >> j.congestion;
        pq.push(j);
    }

    cout << "\n--- Traffic Management Order (Highest Congestion First) ---\n";

    while (!pq.empty()) {
        Junction top = pq.top();
        pq.pop();

        cout << "Junction: " << top.name 
             << " | Congestion Level: " << top.congestion
             << " ‚Üí Adjust signal timing / open extra lane.\n";
    }

    cout << "\nTraffic optimization cycle completed.\n";
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 5 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 5</span>
                    <span class="case-pill">Rail‚ÄìRoad Safety Management</span>
                </div>
                <div class="case-title">Railway Crossing Coordination</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Manages gates at multiple railway crossings where trains and road vehicles intersect. Goal is to minimise gate-closed time while maintaining full safety..</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The system predicts when trains will reach the crossing and closes or opens the gate at the right moments, keeping it safe without unnecessary delays</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Event Scheduling with Priority Queue (Min-Heap by Arrival Time)</div>
                        <div class="info-sub">
                           A min-heap stores train events by arrival time, letting the system handle the earliest event first for safe, collision-free scheduling.

                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 ‚Äì Good Health and Well-Being  SDG 9 ‚Äì Industry, Innovation and Infrastructure</div>
                        <div class="info-sub">
                           Prevents accidents at railway crossings.Enhances safety of transport infrastructure.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>// Case 5 - Railway Crossing Coordination using Min-Heap Event Scheduling

#include <bits/stdc++.h>
using namespace std;

struct Train {
    int arrivalTime;
    string trainName;
};

// Min-heap based on arrival times
struct Compare {
    bool operator()(Train const& a, Train const& b) {
        return a.arrivalTime > b.arrivalTime; // earlier train = higher priority
    }
};

int main() {
    priority_queue<Train, vector<Train>, Compare> pq;

    int n;
    cout << "Enter number of trains: ";
    cin >> n;

    cout << "Enter train name and arrival time:\n";
    for (int i = 0; i < n; i++) {
        Train t;
        cin >> t.trainName >> t.arrivalTime;
        pq.push(t);
    }

    cout << "\n--- Railway Crossing Gate Schedule ---\n";
    while (!pq.empty()) {
        Train t = pq.top();
        pq.pop();
        cout << "Train " << t.trainName 
             << " arriving at time " << t.arrivalTime
             << " ‚Üí Gate CLOSED\n";
    }

    cout << "\nAll trains processed safely.\n";
    return 0;
}
</pre>
                </div>
            </section>

            <!-- ========== CASE 6 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 6</span>
                    <span class="case-pill">  </span>
                </div>
                <div class="case-title">Smart Locker & Lost-and-Found System</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Visitors in Velora often deposit items (bags, helmets, books, gadgets) in smart lockers or submit lost items at counters. The system needs to quickly store, search, and return items to the correct owner using a unique token or ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Items are stored with a unique token ID and basic details. The system lets staff quickly add items, find them by token, or mark them returned, with optional searches by type or color.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Hash Table (Hashing with Separate Chaining or Linear Probing)</div>
                        <div class="info-sub">
                           Hashing gives near-instant (avg O(1)) insert and search by token ID, making item lookup extremely fast.

                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation & Infrastructure  SDG 11 ‚Äì Sustainable Cities & Communities:</div>
                        <div class="info-sub">
                            smart locker / digital tracking system.improves visitor convenience and safety in a smart city park.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>//// Case 6 - Smart Stall Lookup using Hashing (unordered_map)
#include <bits/stdc++.h>
using namespace std;

struct StallInfo {
    string name;
    string category;
    string location;
};

int main() {
    unordered_map<int, StallInfo> stalls; // key = stall ID
    int n;
    cout << "Enter number of stalls: ";
    cin >> n;

    cout << "Enter stallID, name, category, location:\n";
    for (int i = 0; i < n; ++i) {
        int id;
        StallInfo s;
        cin >> id >> s.name >> s.category >> s.location;
        stalls[id] = s;
    }

    cout << "\nEnter stall ID to search: ";
    int query;
    cin >> query;

    auto it = stalls.find(query);
    if (it != stalls.end()) {
        cout << "Stall found:\n";
        cout << "ID: " << query << "\n";
        cout << "Name: " << it->second.name << "\n";
        cout << "Category: " << it->second.category << "\n";
        cout << "Location: " << it->second.location << "\n";
    } else {
        cout << "Stall with ID " << query << " not found.\n";
    }

    return 0;
}

</pre>
                </div>
            </section>

            <!-- ========== CASE 7 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 7</span>
                    <span class="case-pill">Information Retrieval & Search</span>
                </div>
                <div class="case-title">Fast Facility Lookup using a Trie</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Provides instant search for factories, warehouses and service centers by name or code. As the user types, suggestions appear in real time.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each facility has a unique name and ID stored in the system. When an operator types the first few characters, the system must quickly list all matching facilities without scanning the entire dataset, even when thousands of entries exist.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Trie (Prefix Tree) Data Structure</div>
                        <div class="info-sub">
                            Strings are stored character by character in a tree where each path represents a prefix. Looking up all names with a given prefix becomes O(length of prefix), which is ideal for fast auto-complete and search.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure, SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
Speeds up access to industrial information and services. Efficient lookups support smoother industrial operations.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>#include <iostream>
#include <vector>
#include <unordered_map>
#include <string>
using namespace std;

// ---------------- Trie Node ----------------
struct TrieNode {
    unordered_map<char, TrieNode*> next;
    vector<int> ids;   // Stores indices of facilities with this prefix
};

// ---------------- Facility Struct ----------------
struct Facility {
    string name;
    string id;
};

// ---------------- Trie Class ----------------
class Trie {
public:
    Trie() { root = new TrieNode(); }

    void insert(const string &name, int idx) {
        TrieNode* node = root;
        for (char c : toLower(name)) {
            if (!node->next.count(c))
                node->next[c] = new TrieNode();
            node = node->next[c];
            node->ids.push_back(idx);
        }
    }

    vector<int> searchPrefix(const string &prefix) {
        TrieNode* node = root;
        for (char c : toLower(prefix)) {
            if (!node->next.count(c)) return {};
            node = node->next[c];
        }
        return node->ids;
    }

private:
    TrieNode* root;

    string toLower(string s) {
        for (char &c : s) c = tolower(c);
        return s;
    }
};

// ---------------- MAIN PROGRAM ----------------
int main() {
    Trie trie;
    vector<Facility> facilities;

    // Preloaded sample data
    vector<pair<string,string>> demo = {
        {"Alpha Factory", "F001"},
        {"Alpha Warehouse", "W010"},
        {"Beta Service Center", "S020"},
        {"Central Logistics Hub", "H100"},
        {"City West Depot", "D200"}
    };

    // Insert demo data into Trie
    for (auto &p : demo) {
        facilities.push_back({p.first, p.second});
        trie.insert(p.first, facilities.size() - 1);
    }

    cout << "\n--- Fast Facility Lookup Using Trie ---\n";

    while (true) {
        cout << "\n1. Add Facility\n";
        cout << "2. Search by Prefix\n";
        cout << "3. Exit\n";
        cout << "Choice: ";

        int ch;
        cin >> ch;
        cin.ignore();

        if (ch == 1) {
            Facility f;
            cout << "Facility Name: ";
            getline(cin, f.name);
            cout << "Facility ID: ";
            getline(cin, f.id);

            facilities.push_back(f);
            trie.insert(f.name, facilities.size() - 1);

            cout << "Added successfully!\n";
        }
        else if (ch == 2) {
            string pref;
            cout << "Enter prefix: ";
            getline(cin, pref);

            vector<int> result = trie.searchPrefix(pref);

            if (result.empty()) {
                cout << "No facility found.\n";
            } else {
                cout << "\nMatching Facilities:\n";
                for (int idx : result) {
                    cout << " - " << facilities[idx].name
                         << " (ID: " << facilities[idx].id << ")\n";
                }
            }
        }
        else if (ch == 3) {
            cout << "Goodbye!\n";
            break;
        }
        else {
            cout << "Invalid option.\n";
        }
    }

    return 0;
}
</pre>
                </div>
            </section>

            <!-- ========== CASE 8 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 8</span>
                    <span class="case-pill">System Monitoring & Debugging</span>
                </div>
                <div class="case-title">Log Pattern Detection with Brute-Force String Match</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Searches small to medium-sized log files for specific error keywords or patterns. Used by operators during quick manual checks.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>When a fault is reported, engineers provide an error pattern (e.g., "CRITICAL_TIMEOUT"). The system scans recent log files to highlight every occurrence of this pattern so they can see when and where it happened, but log sizes are moderate so extreme optimisation is not mandatory.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Brute-Force Pattern Matching</div>
                        <div class="info-sub">
                          Compares the pattern with every possible position in the log string. The algorithm is simple to implement, easy to debug, and performs well enough for moderate-sized logs, making it suitable when development time is more critical than ultra-high speed.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure, SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Helps maintain reliable industrial IT systems.Reduces downtime and waste by fast fault diagnosis.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>// CASE 9: Log Pattern Detection using Brute-Force Matching
#include <bits/stdc++.h>
using namespace std;

// Brute-force pattern matching function
vector<int> findPattern(const string &logData, const string &pattern) {
    vector<int> positions;
    int n = logData.size();
    int m = pattern.size();

    for (int i = 0; i <= n - m; i++) {
        int j = 0;
        // check pattern match starting at index i
        while (j < m && logData[i + j] == pattern[j]) {
            j++;
        }
        if (j == m) {
            positions.push_back(i); // pattern found at index i
        }
    }
    return positions;
}

int main() {
    string logData, pattern;

    cout << "Enter log text (single line or long text):\n";
    getline(cin, logData);

    cout << "Enter error pattern to search for: ";
    getline(cin, pattern);

    vector<int> result = findPattern(logData, pattern);

    if (result.empty()) {
        cout << "\nPattern NOT FOUND in log.\n";
    } else {
        cout << "\nPattern found at positions: ";
        for (int idx : result) {
            cout << idx << " ";
        }
        cout << "\nTotal occurrences: " << result.size() << "\n";
    }

    return 0;
}
</pre>
                </div>
            </section>

            <!-- ========== CASE 9 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 9</span>
                    <span class="case-pill">Large-Scale System Analytics</span>
                </div>
                <div class="case-title">Industrial Log Error Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Automatically scans huge log streams from multiple industrial machines to detect recurring error signatures. Needs to be faster and more scalable than simple brute-force search.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Production plants generate millions of log lines per day. The system maintains a set of known error patterns and must continuously check incoming logs to detect them quickly. Since logs are long, naive scanning for each pattern would be too slow.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Knuth‚ÄìMorris‚ÄìPratt (KMP) Pattern Matching</div>
                        <div class="info-sub">
                            KMP preprocesses the pattern to build a longest-prefix-suffix (LPS) table, allowing the search to avoid re-checking characters when a mismatch occurs. This gives linear-time matching in the size of the log, which is ideal for high-volume error detection.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure, SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Supports stable and resilient industrial automation.Early detection of faults prevents waste, defects and rework.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>// CASE 10: Industrial Log Error Detection using KMP Algorithm
#include <bits/stdc++.h>
using namespace std;

// Build LPS array (Longest Prefix which is also Suffix)
vector<int> buildLPS(const string &pat) {
    int m = pat.size();
    vector<int> lps(m, 0);
    int len = 0; // length of previous longest prefix suffix

    for (int i = 1; i < m; ) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

// KMP search function
vector<int> KMPSearch(const string &text, const string &pat) {
    vector<int> lps = buildLPS(pat);
    vector<int> positions;

    int n = text.size();
    int m = pat.size();
    int i = 0, j = 0; // text index, pattern index

    while (i < n) {
        if (text[i] == pat[j]) {
            i++;
            j++;
        }
        if (j == m) {
            positions.push_back(i - j); // pattern found at index (i-j)
            j = lps[j - 1];
        } else if (i < n && text[i] != pat[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return positions;
}

int main() {
    string logData, pattern;

    cout << "Enter log data (single line or multiple words):\n";
    getline(cin, logData);

    cout << "Enter error pattern to detect: ";
    getline(cin, pattern);

    vector<int> result = KMPSearch(logData, pattern);

    if (result.empty()) {
        cout << "\nPattern NOT FOUND in log.\n";
    } else {
        cout << "\nPattern found at positions: ";
        for (int idx : result) cout << idx << " ";
        cout << "\nTotal occurrences: " << result.size() << "\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 10 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 10</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Vendor Directory Search</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora maintains a directory of vendors/stalls sorted by ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>It needs fast insert & search, but also keeps the tree height balanced even when many vendors are added.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">AVL TREE</div>
                        <div class="info-sub">
                            AVL tree is a self-balancing BST with O(log n) search, insert, and delete. It avoids skewed trees that make search slow.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
                         Quick vendor identification reduces delays in operations, supporting productive workflows and contributing to stronger economic performance.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre>// Case 9 - Vendor Directory using AVL Tree
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int key;            // e.g., vendor ID
    string name;
    Node *left, *right;
    int height;
    Node(int k, string n) : key(k), name(n), left(nullptr), right(nullptr), height(1) {}
};

int getHeight(Node* n) {
    return n ? n->height : 0;
}

int getBalance(Node* n) {
    return n ? getHeight(n->left) - getHeight(n->right) : 0;
}

Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y;
}

Node* insertNode(Node* node, int key, const string &name) {
    if (!node) return new Node(key, name);

    if (key < node->key)
        node->left = insertNode(node->left, key, name);
    else if (key > node->key)
        node->right = insertNode(node->right, key, name);
    else
        return node; // duplicate IDs not inserted

    node->height = 1 + max(getHeight(node->left), getHeight(node->right));
    int balance = getBalance(node);

    // Left Left
    if (balance > 1 && key < node->left->key)
        return rightRotate(node);
    // Right Right
    if (balance < -1 && key > node->right->key)
        return leftRotate(node);
    // Left Right
    if (balance > 1 && key > node->left->key) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    // Right Left
    if (balance < -1 && key < node->right->key) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}

Node* search(Node* root, int key) {
    if (!root || root->key == key) return root;
    if (key < root->key) return search(root->left, key);
    return search(root->right, key);
}

void inorder(Node* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->key << " - " << root->name << "\n";
    inorder(root->right);
}

int main() {
    Node* root = nullptr;
    int n;
    cout << "Enter number of vendors: ";
    cin >> n;

    cout << "Enter vendorID and name:\n";
    for (int i = 0; i < n; ++i) {
        int id;
        string name;
        cin >> id >> name;
        root = insertNode(root, id, name);
    }

    cout << "\nVendors in sorted order (AVL inorder traversal):\n";
    inorder(root);

    cout << "\nEnter vendorID to search: ";
    int q;
    cin >> q;
    Node* res = search(root, q);
    if (res) cout << "Vendor found: " << res->key << " - " << res->name << "\n";
    else cout << "Vendor not found.\n";

    return 0;
}
</pre>
                </div>
            </section>
          <!-- ========== CASE 11 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 11</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Crowd Density Monitor (Segment Tree)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora divides a walking street into sections. Each section has a current crowd count.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>We need fast updates when more people enter/leave and fast range queries, like ‚Äúhow many people between section 3 and 8?</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Segment tree</div>
                        <div class="info-sub">
                          A segment tree supports range sum queries and point updates in O(log n), ideal for live crowd monitoring dashboards.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities and Communities</div>
                        <div class="info-sub">
                        Real-time crowd monitoring helps prevent overcrowding in public spaces, improving safety and supporting smarter urban management.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
                    <pre> // Case 10 - Crowd Density Monitor using Segment Tree (range sum)
#include <bits/stdc++.h>
using namespace std;

struct SegmentTree {
    int n;
    vector<int> tree;

    SegmentTree(int size) {
        n = size;
        tree.assign(4 * n, 0);
    }

    void build(vector<int> &arr, int idx, int l, int r) {
        if (l == r) {
            tree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(arr, 2 * idx, l, mid);
        build(arr, 2 * idx + 1, mid + 1, r);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void build(vector<int> &arr) {
        build(arr, 1, 0, n - 1);
    }

    void update(int idx, int l, int r, int pos, int val) {
        if (l == r) {
            tree[idx] = val;
            return;
        }
        int mid = (l + r) / 2;
        if (pos <= mid) update(2 * idx, l, mid, pos, val);
        else update(2 * idx + 1, mid + 1, r, pos, val);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void update(int pos, int val) {
        update(1, 0, n - 1, pos, val);
    }

    int query(int idx, int l, int r, int ql, int qr) {
        if (qr < l || ql > r) return 0;         // no overlap
        if (ql <= l && r <= qr) return tree[idx]; // complete overlap
        int mid = (l + r) / 2;
        return query(2 * idx, l, mid, ql, qr) +
               query(2 * idx + 1, mid + 1, r, ql, qr);
    }

    int query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
};

int main() {
    int n;
    cout << "Enter number of sections in street: ";
    cin >> n;

    vector<int> crowd(n);
    cout << "Enter initial crowd count for each section:\n";
    for (int i = 0; i < n; ++i) cin >> crowd[i];

    SegmentTree st(n);
    st.build(crowd);

    while (true) {
        cout << "\n1. Update crowd at a section\n";
        cout << "2. Query total crowd in a range\n";
        cout << "3. Exit\n";
        cout << "Choose option: ";
        int choice;
        cin >> choice;

        if (choice == 1) {
            int pos, val;
            cout << "Enter section index (0-based) and new crowd count: ";
            cin >> pos >> val;
            st.update(pos, val);
        } else if (choice == 2) {
            int l, r;
            cout << "Enter range [l r]: ";
            cin >> l >> r;
            cout << "Total crowd from section " << l << " to " << r
                 << " = " << st.query(l, r) << "\n";
        } else {
            break;
        }
    }

    return 0;
} </pre>
                </div>
            </section>


            <footer>
                KLE TECHNOLOGICAL UNIVERSITY ‚Ä¢ DAA Project 
            </footer>
        </main>
    </div>
</body>
</html>
