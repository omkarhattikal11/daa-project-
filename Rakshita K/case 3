#include <bits/stdc++.h>
using namespace std;

// -------------------------------
// Segment Tree for max waste query
// -------------------------------
class SegmentTree {
public:
    vector<int> tree;
    int n;

    SegmentTree(vector<int>& arr) {
        n = arr.size();
        tree.resize(4*n);
        build(arr, 1, 0, n-1);
    }

    void build(vector<int>& arr, int node, int start, int end) {
        if(start == end) tree[node] = arr[start];
        else {
            int mid = (start + end) / 2;
            build(arr, node*2, start, mid);
            build(arr, node*2+1, mid+1, end);
            tree[node] = max(tree[node*2], tree[node*2+1]);
        }
    }

    int queryMax(int node, int start, int end, int l, int r) {
        if(r < start || l > end) return -1; 
        if(l <= start && end <= r) return tree[node];
        int mid = (start + end) / 2;
        return max(
            queryMax(node*2, start, mid, l, r),
            queryMax(node*2+1, mid+1, end, l, r)
        );
    }
};

// Merge Sort for sorting zones by waste level
void mergeSort(vector<pair<int,int>>& arr) {
    if(arr.size() <= 1) return;

    int mid = arr.size()/2;
    vector<pair<int,int>> left(arr.begin(), arr.begin()+mid);
    vector<pair<int,int>> right(arr.begin()+mid, arr.end());

    mergeSort(left);
    mergeSort(right);

    int i = 0, j = 0, k = 0;
    while(i < left.size() && j < right.size()) {
        if(left[i].second > right[j].second)   // higher waste first
            arr[k++] = left[i++];
        else
            arr[k++] = right[j++];
    }
    while(i < left.size()) arr[k++] = left[i++];
    while(j < right.size()) arr[k++] = right[j++];
}

int main() {

    queue<int> sensorQueue;                           // Queue for incoming sensor data
    unordered_map<int, int> wasteMap;                 // Hash Map (zoneId -> waste level)
    vector<int> beachZones = {30, 45, 10, 60, 20};     // Initial waste values

    SegmentTree seg(beachZones);

    cout << "Max waste in zone 1 to 3: "
         << seg.queryMax(1, 0, beachZones.size()-1, 1, 3) << endl;

    // Add new sensor readings
    sensorQueue.push(12);
    sensorQueue.push(50);
    sensorQueue.push(33);

    // Process queue and update map
    int zoneId = 1;
    while(!sensorQueue.empty()) {
        wasteMap[zoneId++] = sensorQueue.front();
        sensorQueue.pop();
    }

    // Prepare zone-waste pairs for sorting
    vector<pair<int,int>> zonePriority;
    for(auto &e : wasteMap)
        zonePriority.push_back({e.first, e.second});

    mergeSort(zonePriority);

    cout << "\nZones sorted by waste level (high to low):\n";
    for(auto &z : zonePriority)
        cout << "Zone " << z.first << " â†’ Waste: " << z.second << "\n";

    return 0;
}
