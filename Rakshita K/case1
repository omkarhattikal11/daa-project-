#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define INF 1e9

// Graph represented using adjacency list
vector<pair<int,int>> graph[100];  
unordered_map<int, string> hospitalMap;

void dijkstra(int src, int n) {
    vector<int> dist(n, INF);
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        int distance = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        for (auto edge : graph[node]) {
            int next = edge.first;
            int weight = edge.second;

            if (dist[next] > distance + weight) {
                dist[next] = distance + weight;
                pq.push({dist[next], next});
            }
        }
    }

    // Print nearest hospital
    int minDist = INF;
    int nearest = -1;

    for (auto h : hospitalMap) {
        if (dist[h.first] < minDist) {
            minDist = dist[h.first];
            nearest = h.first;
        }
    }

    cout << "\nNearest Hospital: " << hospitalMap[nearest];
    cout << "\nMinimum Distance : " << minDist << " units\n";
}

int main() {
    int n = 6;  // sample city with 6 nodes

    // sample roads
    graph[0].push_back({1, 7});
    graph[0].push_back({2, 9});
    graph[1].push_back({3, 10});
    graph[2].push_back({3, 2});
    graph[3].push_back({4, 1});
    graph[4].push_back({5, 3});

    // mark hospitals
    hospitalMap[4] = "City Hospital";
    hospitalMap[5] = "Metro Care";

    int ambulanceLocation = 0;
    dijkstra(ambulanceLocation, n);

    return 0;
}
