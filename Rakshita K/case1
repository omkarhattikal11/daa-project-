BUSINESS CASE 1: Smart Ambulance Routing System 
1. Business Case Description

In a large city, ambulances often waste precious time due to traffic congestion, unclear road conditions, and inefficient route choices. Even a few minutes of delay can risk a patient’s life.

To solve this, we design a Smart Ambulance Routing System that uses graph algorithms to automatically calculate the quickest path from the ambulance to the nearest suitable hospital.

This system considers:

Road distances

Connectivity between locations

Real-time shortest path calculations

The target is to ensure faster emergency responses, reducing patient risk and improving hospital efficiency.

2. Problem Statement

Ambulances currently depend on manual decision-making or GPS suggestions, which:

May not always choose the shortest route

Take time to analyze

Become inefficient in large, complex cities

Therefore, we need a system that:

Represents the city as a graph

Computes optimal routes automatically

Responds instantly with the best path to the hospital

3. Proposed Solution

We create a Graph-Based Route Optimization Model using:

Graph (Adjacency List) → To store roads

Dijkstra’s Algorithm → To find the fastest route

Min-Heap / Priority Queue → To speed up node selection

Hash Map → To store hospital data and distances

The model calculates the minimum travel distance and outputs:
 Shortest path from ambulance location
 Total distance
 Nearest hospital

4. Algorithms and Data Structures Used

           1. Dijkstra’s Algorithm — Fastest Route Calculation
          It finds the shortest and quickest path from the ambulance to all hospitals.
          Ensures the ambulance always takes the minimum-time route, even in a large network of roads.

           2. Min-Heap (Priority Queue) — Efficient Node Selection
          Dijkstra requires repeatedly picking the next closest node.
          Min-heap makes this selection fast (O(log n)), improving overall performance.

           3. Hash Map — Fast Storage & Retrieval
           Hospital names, locations, and road data must be accessed instantly.
           Hash maps provide O(1) lookup, making hospital search extremely fast.

           4. Graph (Adjacency List) — Representing City Roads
          A city naturally fits a graph: nodes = intersections, edges = roads.
          Adjacency list stores only actual roads → saves memory and speeds up traversal.

5. System Workflow

Input city map:
Each road is stored as an edge with a distance

Ambulance location is taken as the source node

Dijkstra’s algorithm is applied

Distances to all hospitals are analyzed

The hospital with the smallest distance is selected

Shortest path and total distance are displayed

6. CODE
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

#define INF 1e9

// Graph represented using adjacency list
vector<pair<int,int>> graph[100];  
unordered_map<int, string> hospitalMap;

void dijkstra(int src, int n) {
    vector<int> dist(n, INF);
    dist[src] = 0;

    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    pq.push({0, src});

    while (!pq.empty()) {
        int distance = pq.top().first;
        int node = pq.top().second;
        pq.pop();

        for (auto edge : graph[node]) {
            int next = edge.first;
            int weight = edge.second;

            if (dist[next] > distance + weight) {
                dist[next] = distance + weight;
                pq.push({dist[next], next});
            }
        }
    }

    // Print nearest hospital
    int minDist = INF;
    int nearest = -1;

    for (auto h : hospitalMap) {
        if (dist[h.first] < minDist) {
            minDist = dist[h.first];
            nearest = h.first;
        }
    }

    cout << "\nNearest Hospital: " << hospitalMap[nearest];
    cout << "\nMinimum Distance : " << minDist << " units\n";
}

int main() {
    int n = 6;  // sample city with 6 nodes

    // sample roads
    graph[0].push_back({1, 7});
    graph[0].push_back({2, 9});
    graph[1].push_back({3, 10});
    graph[2].push_back({3, 2});
    graph[3].push_back({4, 1});
    graph[4].push_back({5, 3});

    // mark hospitals
    hospitalMap[4] = "City Hospital";
    hospitalMap[5] = "Metro Care";

    int ambulanceLocation = 0;
    dijkstra(ambulanceLocation, n);

    return 0;
}

7. Conclusion

This Smart Ambulance Routing System:

Reduces response time

Improves chances of patient survival

Utilizes efficient algorithms for practical real-world use

By combining graph structures, Dijkstra’s algorithm, and optimized data handling, the system delivers the fastest possible route instantly.
