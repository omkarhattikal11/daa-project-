<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Business Cases ‚Äî VELORA</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <style>
        :root {
            --bg: #050816;
            --bg-alt: #0b1220;
            --panel: #020617;
            --accent: #22c55e;
            --accent-soft: rgba(34, 197, 94, 0.12);
            --text-main: #e5e7eb;
            --text-muted: #9ca3af;
            --border-subtle: rgba(148, 163, 184, 0.32);
            --chip-bg: rgba(15, 23, 42, 0.95);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: radial-gradient(circle at top left, #1f2937 0, #020617 45%, #000 100%);
            color: var(--text-main);
            min-height: 100vh;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        /* TOP NAVBAR */

        .top-nav {
            position: sticky;
            top: 0;
            z-index: 40;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(16px);
            border-bottom: 1px solid rgba(31, 41, 55, 0.9);
        }

        .top-nav-inner {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 18px;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .brand-icon {
            width: 34px;
            height: 34px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e 45%, #16a34a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 16px;
            color: #020617;
        }

        .brand-text-main {
            font-weight: 700;
            font-size: 16px;
            letter-spacing: 0.06em;
        }

        .brand-text-sub {
            font-size: 11px;
            color: var(--text-muted);
        }

        .nav-links {
            display: flex;
            align-items: center;
            gap: 18px;
            font-size: 13px;
        }

        .nav-links a {
            opacity: 0.86;
        }

        .nav-links a:hover {
            opacity: 1;
            color: var(--accent);
        }

        .nav-chip {
            padding: 4px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.9);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--text-muted);
        }

        /* PAGE LAYOUT */

        .page-wrapper {
            max-width: 1200px;
            margin: 0 auto;
            padding: 22px 16px 40px;
            display: grid;
            grid-template-columns: 290px minmax(0, 1fr);
            gap: 22px;
        }

        @media (max-width: 900px) {
            .page-wrapper {
                grid-template-columns: 1fr;
            }
        }

        /* SIDEBAR */

        .sidebar {
            background: linear-gradient(145deg, #020617, #020617 40%, rgba(34, 197, 94, 0.12));
            border-radius: 24px;
            padding: 22px 18px 20px;
            border: 1px solid var(--border-subtle);
            display: flex;
            flex-direction: column;
            gap: 18px;
            position: sticky;
            top: 72px;
            height: fit-content;
        }

        .profile-block {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        .avatar {
            width: 56px;
            height: 56px;
            border-radius: 20px;
            background: radial-gradient(circle at 0 0, #4ade80, #22c55e);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 22px;
            color: #020617;
        }

        .student-name {
            font-size: 19px;
            font-weight: 700;
        }

        .student-meta {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .sidebar-title {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 6px;
        }

        .focus-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .tag {
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--chip-bg);
            border: 1px solid rgba(51, 65, 85, 0.9);
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 10px;
        }

        .stat-card {
            padding: 9px 9px 8px;
            border-radius: 14px;
            background: radial-gradient(circle at 0 0, rgba(34, 197, 94, 0.18), #020617 55%);
            border: 1px solid rgba(55, 65, 81, 0.9);
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-muted);
        }

        .stat-value {
            margin-top: 3px;
            font-size: 17px;
            font-weight: 700;
        }

        .links-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
        }

        .links-list a span {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
        }

        .links-list a:hover {
            color: var(--accent);
        }

        /* MAIN CONTENT */

        .content {
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }

        .page-header h1 {
            font-size: 24px;
            letter-spacing: 0.04em;
        }

        .page-subtag {
            font-size: 11px;
            padding: 5px 11px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
        }

        .section-label {
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: var(--text-muted);
        }

        /* CASE BLOCKS */

        .case {
            margin-top: 8px;
            border-radius: 22px;
            background: linear-gradient(150deg, #020617, #020617 55%, rgba(34, 197, 94, 0.12));
            border: 1px solid rgba(55, 65, 81, 0.95);
            padding: 16px 16px 14px;
        }

        .case + .case {
            margin-top: 14px;
        }

        .case-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-pill {
            padding: 3px 9px;
            border-radius: 999px;
            border: 1px solid rgba(55, 65, 81, 0.95);
            background: rgba(15, 23, 42, 0.95);
        }

        .case-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 6px;
        }

        .case-field {
            margin-top: 6px;
        }

        .case-field h3 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .case-field p {
            font-size: 13px;
            color: var(--text-main);
            line-height: 1.7;
        }

        .case-grid {
            margin-top: 10px;
            display: grid;
            grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
            gap: 10px;
        }

        @media (max-width: 800px) {
            .case-grid {
                grid-template-columns: 1fr;
            }
        }

        .info-card {
            border-radius: 16px;
            padding: 10px 12px 10px;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(37, 99, 235, 0.2);
        }

        .info-label-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            font-size: 13px;
            font-weight: 600;
        }

        .info-icon {
            width: 18px;
            height: 18px;
            border-radius: 6px;
            background: var(--accent-soft);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
        }

        .info-main {
            font-size: 13px;
            font-weight: 600;
        }

        .info-sub {
            margin-top: 3px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .code-block {
            margin-top: 10px;
            border-radius: 14px;
            background: #020617;
            border: 1px solid rgba(31, 41, 55, 0.95);
            padding: 10px 10px 8px;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            margin-bottom: 6px;
        }

        .code-title {
            font-weight: 600;
        }

        .copy-btn {
            padding: 4px 9px;
            border-radius: 999px;
            border: none;
            font-size: 11px;
            cursor: pointer;
            background: linear-gradient(135deg, #22c55e, #4ade80);
            color: #020617;
        }

        pre {
            margin: 0;
            font-family: "JetBrains Mono", "Fira Code", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
            color: #e5e7eb;
        }

        footer {
            margin-top: 16px;
            font-size: 11px;
            color: var(--text-muted);
            text-align: right;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <!-- TOP NAVBAR -->
    <header class="top-nav">
        <div class="top-nav-inner">
            <div class="brand">
                <div class="brand-icon">CD</div>
                <div>
                    <div class="brand-text-main">CITY DESIGN</div>
                    <div class="brand-text-sub">DAA ‚Äî Design &amp; Analysis of Algorithms</div>
                </div>
            </div>
            <nav class="nav-links">
                <a href="index.html">Home</a>
                <a href="about.html">About</a>
                <a href="project.html">Project</a>
                <a href="Velora.html">City-Velora</a>
                <a href="Rakshita.html">Rakshita</a>
                <a href="satish.html">Satish</a>
                <a href="aditya.html">Aditya</a>
                <a href="omkar.html">Omkar</a>
                <a href="#">Collabz</a>
                <span class="nav-chip">DAA ‚Ä¢ Project</span>
            </nav>
        </div>
    </header>

    <div class="page-wrapper">
        <!-- SIDEBAR -->
        <aside class="sidebar">
            <div class="profile-block">
                <div class="avatar">OH</div>
                <div>
                    <div class="student-name">OMKAR HATTIKAL</div>
                    <div class="student-meta">
                        Roll No: 213 ‚Ä¢ Dept. of CSE<br>
                        SEMESTER ‚Ä¢ DESIGN ANALYSIS AND ALGORITHMS
                    </div>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Focus Areas</div>
                <div class="focus-tags">
                    <span class="tag">Algorithms</span>
                    <span class="tag">Trees</span>
                    <span class="tag">Sorting</span>
                </div>
            </div>

            <div>
                <div class="sidebar-title">Project Snapshot</div>
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">Business Cases</div>
                        <div class="stat-value">15</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Algorithms</div>
                        <div class="stat-value">15+</div>
                    </div>
                </div>
            </div>

            <div>
    <div class="sidebar-title">Links</div>
    <div class="links-list">
        <a href="https://github.com/omkarhattikal11/daa-project" target="_blank">
            GitHub Repository
            <span>"https://github.com/omkarhattikal11/daa-project-.git"</span>
        </a>
    </div>
</div>

        </aside>

        <!-- MAIN CONTENT -->
        <main class="content">
            <div class="page-header">
                <h1>Business Cases ‚Äî VELORA</h1>
                <div class="page-subtag">DAA ‚Ä¢ Project</div>
            </div>

            <div class="section-label" style="margin-top:10px;">Business Cases</div>

            <!-- ========== CASE 1 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 1</span>
                    <span class="case-pill"> Logistics & Supply Chain </span>
                </div>
                <div class="case-title">Industrial Transport Route Optimization</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Optimizes transport routes between factories and warehouses to reduce travel time and fuel cost.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Roads between locations have different travel times. The system finds the quickest route for each delivery by modeling the network as a weighted graph.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Dijkstra‚Äôs Algorithm</div>
                        <div class="info-sub">
                            It efficiently finds the shortest travel-time path in a weighted road network.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Industry, Innovation & Infrastructure</div>
                        <div class="info-sub">
                           Supports efficient logistics and reduces fuel waste.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Edge {
    int to;
    int w; // travel time or cost
};

vector&lt;vector&lt;Edge&gt;&gt; graph;

vector&lt;int&gt; dijkstra(int n, int src) {
    const int INF = 1e9;
    vector&lt;int&gt; dist(n, INF);
    dist[src] = 0;

    using P = pair&lt;int,int&gt;; // (dist, node)
    priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq;
    pq.push({0, src});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;

        for (auto &e : graph[u]) {
            int v = e.to;
            int nd = d + e.w;
            if (nd &lt; dist[v]) {
                dist[v] = nd;
                pq.push({nd, v});
            }
        }
    }
    return dist;
}

int main() {
    int n = 6; // number of locations (0..5)
    graph.assign(n, {});

    auto addRoad = [&](int u, int v, int w) {
        graph[u].push_back({v, w});
        graph[v].push_back({u, w}); // undirected road
    };

    // sample roads with travel time
    addRoad(0, 1, 4);
    addRoad(0, 2, 2);
    addRoad(1, 2, 1);
    addRoad(1, 3, 5);
    addRoad(2, 3, 8);
    addRoad(2, 4, 10);
    addRoad(3, 5, 2);
    addRoad(4, 5, 3);

    int source = 0; // factory
    vector&lt;int&gt; dist = dijkstra(n, source);

    cout &lt;&lt; "Minimum travel time from source " &lt;&lt; source &lt;&lt; ":\n";
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; "Location " &lt;&lt; i &lt;&lt; " : ";
        if (dist[i] == 1e9) cout &lt;&lt; "unreachable\n";
        else cout &lt;&lt; dist[i] &lt;&lt; " units\n";
    }
    return 0;
}</pre> 
<div class="case-field">
  <h3>Efficiency Analysis</h3>
  <p>
    Dijkstra‚Äôs algorithm runs in <strong>O((V + E) log V)</strong> time
    when implemented using a priority queue. Space complexity is
    <strong>O(V)</strong> for storing distances and visited nodes.
    This ensures fast route computation even for large road networks.
  </p>
</div>

<div class="case-field">
  <h3>Flowchart Diagram</h3>
  <p>
    Start ‚Üí Initialize distances ‚Üí Select nearest unvisited node ‚Üí
    Relax adjacent edges ‚Üí Repeat until all nodes processed ‚Üí Output shortest paths
  </p>
</div>

                </div>
            </section>

            <!-- ========== CASE 2 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 2</span>
                    <span class="case-pill">Urban Utilities & Environment</span>
                </div>
                <div class="case-title">Waste & Water Management Scheduling</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Schedules waste collection and water tanker dispatch based on urgency and deadlines.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Requests arrive with different priorities and deadlines. The system always processes the highest-priority, earliest-deadline task first.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Priority Queue (Min-Heap)</div>
                        <div class="info-sub">
                         It automatically keeps the most urgent request at the top for fast scheduling.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 6 ‚Äî Clean Water & Sanitation</div>
                        <div class="info-sub">
                           Ensures timely waste disposal and water supply.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Request {
    string id;
    int deadline; // smaller = earlier
    int priority; // higher = more important
};

struct Compare {
    bool operator()(const Request &amp;a, const Request &amp;b) const {
        if (a.deadline == b.deadline)
            return a.priority &lt; b.priority; // higher priority first
        return a.deadline &gt; b.deadline;     // earlier deadline first
    }
};

int main() {
    priority_queue&lt;Request, vector&lt;Request&gt;, Compare&gt; pq;

    // id, deadline (hour), priority
    pq.push({"Waste-Truck-A", 10, 2});
    pq.push({"Water-Tanker-1", 9, 1});
    pq.push({"Waste-Truck-B", 11, 3});
    pq.push({"Water-Tanker-2", 10, 5});

    cout &lt;&lt; "Service order (earliest &amp; highest priority first):\n";
    while (!pq.empty()) {
        Request r = pq.top(); pq.pop();
        cout &lt;&lt; "Request: " &lt;&lt; r.id 
             &lt;&lt; ", Deadline: " &lt;&lt; r.deadline
             &lt;&lt; ", Priority: " &lt;&lt; r.priority &lt;&lt; "\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 3 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 3</span>
                    <span class="case-pill"> Utility Monitoring & Maintenance </span>
                </div>
                <div class="case-title">Pipeline Network Fault Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Detects which pipeline sections stop receiving flow when a pipe fails.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The pipeline is a graph. When a connection breaks, BFS identifies which nodes are still reachable.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">BFS (Breadth-First Search)</div>
                        <div class="info-sub">
                           It quickly checks connectivity from the source to detect fault-affected areas.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Infrastructure</div>
                        <div class="info-sub">
                           Ensures reliable and safe pipeline systems.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;vector&lt;int&gt;&gt; graph;

vector&lt;int&gt; bfs(int n, int src) {
    vector&lt;int&gt; visited(n, 0);
    queue&lt;int&gt; q;
    q.push(src);
    visited[src] = 1;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = 1;
                q.push(v);
            }
        }
    }
    return visited;
}

int main() {
    int n = 7;
    graph.assign(n, {});

    auto addPipe = [&](int u, int v) {
        graph[u].push_back(v);
        graph[v].push_back(u);
    };

    addPipe(0,1);
    addPipe(1,2);
    addPipe(2,3);
    addPipe(1,4);
    addPipe(4,5);
    addPipe(5,6);

    int faultyU = 1, faultyV = 4; // faulty pipe between 1 and 4

    // remove faulty edge logically by building a new graph
    vector&lt;vector&lt;int&gt;&gt; newGraph(n);
    for (int u = 0; u &lt; n; ++u) {
        for (int v : graph[u]) {
            if ((u == faultyU &amp;&amp; v == faultyV) ||
                (u == faultyV &amp;&amp; v == faultyU)) continue;
            newGraph[u].push_back(v);
        }
    }
    graph = newGraph;

    vector&lt;int&gt; reachable = bfs(n, 0); // source station 0

    cout &lt;&lt; "Nodes reachable from source after fault:\n";
    for (int i = 0; i &lt; n; ++i) {
        if (reachable[i]) cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " OK\n";
        else cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " affected by fault\n";
    }
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 4 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 4</span>
                    <span class="case-pill"> Intelligent Transportation Systems </span>
                </div>
                <div class="case-title">Highway Traffic Flow Optimization (NH-66)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Estimates fastest travel time between highway junctions considering congestion.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each segment has a base time + congestion value. The system computes the minimum-time path for vehicles.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Max-Heap / Priority Queue (Heapification)</div>
                        <div class="info-sub">
                            Each junction‚Äôs congestion level is stored in a max-heap. The algorithm repeatedly picks the highest-congestion intersections to adjust signal timings first, which matches the need to always handle the ‚Äúworst traffic‚Äù area in real time.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äî Sustainable Cities</div>
                        <div class="info-sub">
                           Reduces congestion and improves transport efficiency.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 4: Highway Traffic Flow Optimization (NH-66)
// Algorithm: Max-Heap Priority Queue (Handle highest congestion first)

#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Junction {
    string name;
    int congestion;  // number of vehicles / congestion score
};

// Max-heap comparator (higher congestion = higher priority)
struct Compare {
    bool operator()(const Junction &amp;a, const Junction &amp;b) {
        return a.congestion &lt; b.congestion;  
    }
};

int main() {
    priority_queue&lt;Junction, vector&lt;Junction&gt;, Compare&gt; pq;

    int n;
    cout &lt;&lt; "Enter number of highway junctions: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter junction name and congestion level:\n";
    for (int i = 0; i &lt; n; i++) {
        Junction j;
        cin &gt;&gt; j.name &gt;&gt; j.congestion;
        pq.push(j);
    }

    cout &lt;&lt; "\n--- Traffic Management Order (Highest Congestion First) ---\n";

    while (!pq.empty()) {
        Junction top = pq.top();
        pq.pop();

        cout &lt;&lt; "Junction: " &lt;&lt; top.name 
             &lt;&lt; " | Congestion Level: " &lt;&lt; top.congestion
             &lt;&lt; " \u2192 Adjust signal timing / open extra lane.\n";
    }

    cout &lt;&lt; "\nTraffic optimization cycle completed.\n";
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 5 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 5</span>
                    <span class="case-pill">Rail‚ÄìRoad Safety Management</span>
                </div>
                <div class="case-title">Railway Crossing Coordination</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Manages gates at multiple railway crossings where trains and road vehicles intersect. Goal is to minimise gate-closed time while maintaining full safety.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>The system predicts when trains will reach the crossing and closes or opens the gate at the right moments, keeping it safe without unnecessary delays.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Event Scheduling with Priority Queue (Min-Heap by Arrival Time)</div>
                        <div class="info-sub">
                           A min-heap stores train events by arrival time, letting the system handle the earliest event first for safe, collision-free scheduling.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 ‚Äì Good Health and Well-Being; SDG 9 ‚Äì Industry, Innovation and Infrastructure</div>
                        <div class="info-sub">
                           Prevents accidents at railway crossings. Enhances safety of transport infrastructure.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 5 - Railway Crossing Coordination using Min-Heap Event Scheduling

#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Train {
    int arrivalTime;
    string trainName;
};

// Min-heap based on arrival times
struct CompareTrain {
    bool operator()(Train const&amp; a, Train const&amp; b) {
        return a.arrivalTime &gt; b.arrivalTime; // earlier train = higher priority
    }
};

int main() {
    priority_queue&lt;Train, vector&lt;Train&gt;, CompareTrain&gt; pq;

    int n;
    cout &lt;&lt; "Enter number of trains: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter train name and arrival time:\n";
    for (int i = 0; i &lt; n; i++) {
        Train t;
        cin &gt;&gt; t.trainName &gt;&gt; t.arrivalTime;
        pq.push(t);
    }

    cout &lt;&lt; "\n--- Railway Crossing Gate Schedule ---\n";
    while (!pq.empty()) {
        Train t = pq.top();
        pq.pop();
        cout &lt;&lt; "Train " &lt;&lt; t.trainName 
             &lt;&lt; " arriving at time " &lt;&lt; t.arrivalTime
             &lt;&lt; " \u2192 Gate CLOSED\n";
    }

    cout &lt;&lt; "\nAll trains processed safely.\n";
    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 6 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 6</span>
                    <span class="case-pill"> Smart Storage & Security </span>
                </div>
                <div class="case-title">Smart Locker & Lost-and-Found System</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Visitors deposit items (bags, helmets, books, gadgets) in smart lockers or submit lost items at counters. The system must quickly store, search, and return items using a unique token or ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Items are stored with a unique token ID and basic details. The system lets staff quickly add items, find them by token, or mark them returned, with optional searches by type or color.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Hash Table (Hashing with unordered_map)</div>
                        <div class="info-sub">
                           Hashing gives near-instant (avg O(1)) insert and search by token ID, making item lookup extremely fast.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation &amp; Infrastructure; SDG 11 ‚Äì Sustainable Cities &amp; Communities</div>
                        <div class="info-sub">
                            Smart locker / digital tracking system improves visitor convenience and safety in a smart city park.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 6 - Smart Stall/Locker Lookup using Hashing (unordered_map)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct StallInfo {
    string name;
    string category;
    string location;
};

int main() {
    unordered_map&lt;int, StallInfo&gt; stalls; // key = stall ID
    int n;
    cout &lt;&lt; "Enter number of stalls: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter stallID, name, category, location:\n";
    for (int i = 0; i &lt; n; ++i) {
        int id;
        StallInfo s;
        cin &gt;&gt; id &gt;&gt; s.name &gt;&gt; s.category &gt;&gt; s.location;
        stalls[id] = s;
    }

    cout &lt;&lt; "\nEnter stall ID to search: ";
    int query;
    cin &gt;&gt; query;

    auto it = stalls.find(query);
    if (it != stalls.end()) {
        cout &lt;&lt; "Stall found:\n";
        cout &lt;&lt; "ID: " &lt;&lt; query &lt;&lt; "\n";
        cout &lt;&lt; "Name: " &lt;&lt; it-&gt;second.name &lt;&lt; "\n";
        cout &lt;&lt; "Category: " &lt;&lt; it-&gt;second.category &lt;&lt; "\n";
        cout &lt;&lt; "Location: " &lt;&lt; it-&gt;second.location &lt;&lt; "\n";
    } else {
        cout &lt;&lt; "Stall with ID " &lt;&lt; query &lt;&lt; " not found.\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 7 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 7</span>
                    <span class="case-pill">Information Retrieval & Search</span>
                </div>
                <div class="case-title">Fast Facility Lookup using a Trie</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Provides instant search for factories, warehouses and service centers by name or code. As the user types, suggestions appear in real time.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each facility has a unique name and ID stored in the system. When an operator types the first few characters, the system must quickly list all matching facilities without scanning the entire dataset, even when thousands of entries exist.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Trie (Prefix Tree) Data Structure</div>
                        <div class="info-sub">
                            Strings are stored character by character in a tree where each path represents a prefix. Looking up all names with a given prefix becomes O(length of prefix), which is ideal for fast auto-complete and search.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
Speeds up access to industrial information and services. Efficient lookups support smoother industrial operations.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;

// ---------------- Trie Node ----------------
struct TrieNode {
    unordered_map&lt;char, TrieNode*&gt; next;
    vector&lt;int&gt; ids;   // Stores indices of facilities with this prefix
};

// ---------------- Facility Struct ----------------
struct Facility {
    string name;
    string id;
};

// ---------------- Trie Class ----------------
class Trie {
public:
    Trie() { root = new TrieNode(); }

    void insert(const string &amp;name, int idx) {
        TrieNode* node = root;
        for (char c : toLower(name)) {
            if (!node-&gt;next.count(c))
                node-&gt;next[c] = new TrieNode();
            node = node-&gt;next[c];
            node-&gt;ids.push_back(idx);
        }
    }

    vector&lt;int&gt; searchPrefix(const string &amp;prefix) {
        TrieNode* node = root;
        for (char c : toLower(prefix)) {
            if (!node-&gt;next.count(c)) return {};
            node = node-&gt;next[c];
        }
        return node-&gt;ids;
    }

private:
    TrieNode* root;

    string toLower(string s) {
        for (char &amp;c : s) c = tolower(c);
        return s;
    }
};

// ---------------- MAIN PROGRAM ----------------
int main() {
    Trie trie;
    vector&lt;Facility&gt; facilities;

    // Preloaded sample data
    vector&lt;pair&lt;string,string&gt;&gt; demo = {
        {"Alpha Factory", "F001"},
        {"Alpha Warehouse", "W010"},
        {"Beta Service Center", "S020"},
        {"Central Logistics Hub", "H100"},
        {"City West Depot", "D200"}
    };

    // Insert demo data into Trie
    for (auto &amp;p : demo) {
        facilities.push_back({p.first, p.second});
        trie.insert(p.first, facilities.size() - 1);
    }

    cout &lt;&lt; "\n--- Fast Facility Lookup Using Trie ---\n";

    while (true) {
        cout &lt;&lt; "\n1. Add Facility\n";
        cout &lt;&lt; "2. Search by Prefix\n";
        cout &lt;&lt; "3. Exit\n";
        cout &lt;&lt; "Choice: ";

        int ch;
        cin &gt;&gt; ch;
        cin.ignore();

        if (ch == 1) {
            Facility f;
            cout &lt;&lt; "Facility Name: ";
            getline(cin, f.name);
            cout &lt;&lt; "Facility ID: ";
            getline(cin, f.id);

            facilities.push_back(f);
            trie.insert(f.name, facilities.size() - 1);

            cout &lt;&lt; "Added successfully!\n";
        }
        else if (ch == 2) {
            string pref;
            cout &lt;&lt; "Enter prefix: ";
            getline(cin, pref);

            vector&lt;int&gt; result = trie.searchPrefix(pref);

            if (result.empty()) {
                cout &lt;&lt; "No facility found.\n";
            } else {
                cout &lt;&lt; "\nMatching Facilities:\n";
                for (int idx : result) {
                    cout &lt;&lt; " - " &lt;&lt; facilities[idx].name
                         &lt;&lt; " (ID: " &lt;&lt; facilities[idx].id &lt;&lt; ")\n";
                }
            }
        }
        else if (ch == 3) {
            cout &lt;&lt; "Goodbye!\n";
            break;
        }
        else {
            cout &lt;&lt; "Invalid option.\n";
        }
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 8 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 8</span>
                    <span class="case-pill">System Monitoring & Debugging</span>
                </div>
                <div class="case-title">Log Pattern Detection with Brute-Force String Match</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Searches small to medium-sized log files for specific error keywords or patterns. Used by operators during quick manual checks.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>When a fault is reported, engineers provide an error pattern (e.g., "CRITICAL_TIMEOUT"). The system scans recent log files to highlight every occurrence of this pattern so they can see when and where it happened, but log sizes are moderate so extreme optimisation is not mandatory.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Brute-Force Pattern Matching</div>
                        <div class="info-sub">
                          Compares the pattern with every possible position in the log string. The algorithm is simple to implement, easy to debug, and performs well enough for moderate-sized logs, making it suitable when development time is more critical than ultra-high speed.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Helps maintain reliable industrial IT systems. Reduces downtime and waste by fast fault diagnosis.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 8: Log Pattern Detection using Brute-Force Matching
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Brute-force pattern matching function
vector&lt;int&gt; findPattern(const string &amp;logData, const string &amp;pattern) {
    vector&lt;int&gt; positions;
    int n = logData.size();
    int m = pattern.size();

    for (int i = 0; i &lt;= n - m; i++) {
        int j = 0;
        // check pattern match starting at index i
        while (j &lt; m &amp;&amp; logData[i + j] == pattern[j]) {
            j++;
        }
        if (j == m) {
            positions.push_back(i); // pattern found at index i
        }
    }
    return positions;
}

int main() {
    string logData, pattern;

    cout &lt;&lt; "Enter log text (single line or long text):\n";
    getline(cin, logData);

    cout &lt;&lt; "Enter error pattern to search for: ";
    getline(cin, pattern);

    vector&lt;int&gt; result = findPattern(logData, pattern);

    if (result.empty()) {
        cout &lt;&lt; "\nPattern NOT FOUND in log.\n";
    } else {
        cout &lt;&lt; "\nPattern found at positions: ";
        for (int idx : result) {
            cout &lt;&lt; idx &lt;&lt; " ";
        }
        cout &lt;&lt; "\nTotal occurrences: " &lt;&lt; result.size() &lt;&lt; "\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 9 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 9</span>
                    <span class="case-pill">Large-Scale System Analytics</span>
                </div>
                <div class="case-title">Industrial Log Error Detection</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Automatically scans huge log streams from multiple industrial machines to detect recurring error signatures. Needs to be faster and more scalable than simple brute-force search.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Production plants generate millions of log lines per day. The system maintains a set of known error patterns and must continuously check incoming logs to detect them quickly. Since logs are long, naive scanning for each pattern would be too slow.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Knuth‚ÄìMorris‚ÄìPratt (KMP) Pattern Matching</div>
                        <div class="info-sub">
                            KMP preprocesses the pattern to build a longest-prefix-suffix (LPS) table, allowing the search to avoid re-checking characters when a mismatch occurs. This gives linear-time matching in the size of the log, which is ideal for high-volume error detection.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äì Industry, Innovation and Infrastructure; SDG 12 ‚Äì Responsible Consumption and Production</div>
                        <div class="info-sub">
                            Supports stable and resilient industrial automation. Early detection of faults prevents waste, defects and rework.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// CASE 9: Industrial Log Error Detection using KMP Algorithm
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Build LPS array (Longest Prefix which is also Suffix)
vector&lt;int&gt; buildLPS(const string &amp;pat) {
    int m = pat.size();
    vector&lt;int&gt; lps(m, 0);
    int len = 0; // length of previous longest prefix suffix

    for (int i = 1; i &lt; m; ) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        } else {
            if (len != 0) {
                len = lps[len - 1];
            } else {
                lps[i] = 0;
                i++;
            }
        }
    }
    return lps;
}

// KMP search function
vector&lt;int&gt; KMPSearch(const string &amp;text, const string &amp;pat) {
    vector&lt;int&gt; lps = buildLPS(pat);
    vector&lt;int&gt; positions;

    int n = text.size();
    int m = pat.size();
    int i = 0, j = 0; // text index, pattern index

    while (i &lt; n) {
        if (text[i] == pat[j]) {
            i++;
            j++;
        }
        if (j == m) {
            positions.push_back(i - j); // pattern found at index (i-j)
            j = lps[j - 1];
        } else if (i &lt; n &amp;&amp; text[i] != pat[j]) {
            if (j != 0) j = lps[j - 1];
            else i++;
        }
    }

    return positions;
}

int main() {
    string logData, pattern;

    cout &lt;&lt; "Enter log data (single line or multiple words):\n";
    getline(cin, logData);

    cout &lt;&lt; "Enter error pattern to detect: ";
    getline(cin, pattern);

    vector&lt;int&gt; result = KMPSearch(logData, pattern);

    if (result.empty()) {
        cout &lt;&lt; "\nPattern NOT FOUND in log.\n";
    } else {
        cout &lt;&lt; "\nPattern found at positions: ";
        for (int idx : result) cout &lt;&lt; idx &lt;&lt; " ";
        cout &lt;&lt; "\nTotal occurrences: " &lt;&lt; result.size() &lt;&lt; "\n";
    }

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 10 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 10</span>
                    <span class="case-pill"> Vendor Management </span>
                </div>
                <div class="case-title">Vendor Directory Search</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora maintains a directory of vendors/stalls sorted by ID.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>It needs fast insert &amp; search, but also keeps the tree height balanced even when many vendors are added.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">AVL Tree</div>
                        <div class="info-sub">
                            AVL tree is a self-balancing BST with O(log n) search, insert, and delete. It avoids skewed trees that make search slow.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 8 ‚Äì Decent Work and Economic Growth</div>
                        <div class="info-sub">
                         Quick vendor identification reduces delays in operations, supporting productive workflows and contributing to stronger economic performance.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 10 - Vendor Directory using AVL Tree
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct Node {
    int key;            // e.g., vendor ID
    string name;
    Node *left, *right;
    int height;
    Node(int k, string n) : key(k), name(n), left(nullptr), right(nullptr), height(1) {}
};

int getHeight(Node* n) {
    return n ? n-&gt;height : 0;
}

int getBalance(Node* n) {
    return n ? getHeight(n-&gt;left) - getHeight(n-&gt;right) : 0;
}

Node* rightRotate(Node* y) {
    Node* x = y-&gt;left;
    Node* T2 = x-&gt;right;

    x-&gt;right = y;
    y-&gt;left = T2;

    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;
    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;

    return x;
}

Node* leftRotate(Node* x) {
    Node* y = x-&gt;right;
    Node* T2 = y-&gt;left;

    y-&gt;left = x;
    x-&gt;right = T2;

    x-&gt;height = max(getHeight(x-&gt;left), getHeight(x-&gt;right)) + 1;
    y-&gt;height = max(getHeight(y-&gt;left), getHeight(y-&gt;right)) + 1;

    return y;
}

Node* insertNode(Node* node, int key, const string &amp;name) {
    if (!node) return new Node(key, name);

    if (key &lt; node-&gt;key)
        node-&gt;left = insertNode(node-&gt;left, key, name);
    else if (key &gt; node-&gt;key)
        node-&gt;right = insertNode(node-&gt;right, key, name);
    else
        return node; // duplicate IDs not inserted

    node-&gt;height = 1 + max(getHeight(node-&gt;left), getHeight(node-&gt;right));
    int balance = getBalance(node);

    // Left Left
    if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key)
        return rightRotate(node);
    // Right Right
    if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)
        return leftRotate(node);
    // Left Right
    if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) {
        node-&gt;left = leftRotate(node-&gt;left);
        return rightRotate(node);
    }
    // Right Left
    if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) {
        node-&gt;right = rightRotate(node-&gt;right);
        return leftRotate(node);
    }

    return node;
}

Node* search(Node* root, int key) {
    if (!root || root-&gt;key == key) return root;
    if (key &lt; root-&gt;key) return search(root-&gt;left, key);
    return search(root-&gt;right, key);
}

void inorder(Node* root) {
    if (!root) return;
    inorder(root-&gt;left);
    cout &lt;&lt; root-&gt;key &lt;&lt; " - " &lt;&lt; root-&gt;name &lt;&lt; "\n";
    inorder(root-&gt;right);
}

int main() {
    Node* root = nullptr;
    int n;
    cout &lt;&lt; "Enter number of vendors: ";
    cin &gt;&gt; n;

    cout &lt;&lt; "Enter vendorID and name:\n";
    for (int i = 0; i &lt; n; ++i) {
        int id;
        string name;
        cin &gt;&gt; id &gt;&gt; name;
        root = insertNode(root, id, name);
    }

    cout &lt;&lt; "\nVendors in sorted order (AVL inorder traversal):\n";
    inorder(root);

    cout &lt;&lt; "\nEnter vendorID to search: ";
    int q;
    cin &gt;&gt; q;
    Node* res = search(root, q);
    if (res) cout &lt;&lt; "Vendor found: " &lt;&lt; res-&gt;key &lt;&lt; " - " &lt;&lt; res-&gt;name &lt;&lt; "\n";
    else cout &lt;&lt; "Vendor not found.\n";

    return 0;
}</pre>
                </div>
            </section>

            <!-- ========== CASE 11 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 11</span>
                    <span class="case-pill"> Crowd Management </span>
                </div>
                <div class="case-title">Crowd Density Monitor (Segment Tree)</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora divides a walking street into sections. Each section has a current crowd count.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>We need fast updates when more people enter/leave and fast range queries, like ‚Äúhow many people between section 3 and 8?‚Äù.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Segment Tree</div>
                        <div class="info-sub">
                          A segment tree supports range sum queries and point updates in O(log n), ideal for live crowd monitoring dashboards.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities and Communities</div>
                        <div class="info-sub">
                        Real-time crowd monitoring helps prevent overcrowding in public spaces, improving safety and supporting smarter urban management.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// Case 11 - Crowd Density Monitor using Segment Tree (range sum)
#include &lt;bits/stdc++.h&gt;
using namespace std;

struct SegmentTree {
    int n;
    vector&lt;int&gt; tree;

    SegmentTree(int size) {
        n = size;
        tree.assign(4 * n, 0);
    }

    void build(vector&lt;int&gt; &amp;arr, int idx, int l, int r) {
        if (l == r) {
            tree[idx] = arr[l];
            return;
        }
        int mid = (l + r) / 2;
        build(arr, 2 * idx, l, mid);
        build(arr, 2 * idx + 1, mid + 1, r);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void build(vector&lt;int&gt; &amp;arr) {
        build(arr, 1, 0, n - 1);
    }

    void update(int idx, int l, int r, int pos, int val) {
        if (l == r) {
            tree[idx] = val;
            return;
        }
        int mid = (l + r) / 2;
        if (pos &lt;= mid) update(2 * idx, l, mid, pos, val);
        else update(2 * idx + 1, mid + 1, r, pos, val);
        tree[idx] = tree[2 * idx] + tree[2 * idx + 1];
    }

    void update(int pos, int val) {
        update(1, 0, n - 1, pos, val);
    }

    int query(int idx, int l, int r, int ql, int qr) {
        if (qr &lt; l || ql &gt; r) return 0;         // no overlap
        if (ql &lt;= l &amp;&amp; r &lt;= qr) return tree[idx]; // complete overlap
        int mid = (l + r) / 2;
        return query(2 * idx, l, mid, ql, qr) +
               query(2 * idx + 1, mid + 1, r, ql, qr);
    }

    int query(int l, int r) {
        return query(1, 0, n - 1, l, r);
    }
};

int main() {
    int n;
    cout &lt;&lt; "Enter number of sections in street: ";
    cin &gt;&gt; n;

    vector&lt;int&gt; crowd(n);
    cout &lt;&lt; "Enter initial crowd count for each section:\n";
    for (int i = 0; i &lt; n; ++i) cin &gt;&gt; crowd[i];

    SegmentTree st(n);
    st.build(crowd);

    while (true) {
        cout &lt;&lt; "\n1. Update crowd at a section\n";
        cout &lt;&lt; "2. Query total crowd in a range\n";
        cout &lt;&lt; "3. Exit\n";
        cout &lt;&lt; "Choose option: ";
        int choice;
        cin &gt;&gt; choice;

        if (choice == 1) {
            int pos, val;
            cout &lt;&lt; "Enter section index (0-based) and new crowd count: ";
            cin &gt;&gt; pos &gt;&gt; val;
            st.update(pos, val);
        } else if (choice == 2) {
            int l, r;
            cout &lt;&lt; "Enter range [l r]: ";
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; "Total crowd from section " &lt;&lt; l &lt;&lt; " to " &lt;&lt; r
                 &lt;&lt; " = " &lt;&lt; st.query(l, r) &lt;&lt; "\n";
        } else {
            break;
        }
    }

    return 0;
}</pre>
                </div>
            </section>
            <!-- ========== CASE 12 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 12</span>
                    <span class="case-pill"> Research library & digital knowledge center</span>
                </div>
                <div class="case-title">Velora Knowledge Hub Search</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora‚Äôs Knowledge Hub is a central library where students and visitors search for books, research papers, and digital content. The system must quickly locate resources even when thousands of entries are stored.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Every resource (book, paper, video) is stored with a unique ID, title, and short abstract. Users can search by title or by keyword. The system first locates the right resource by title, then highlights where the keyword appears inside the abstract/description.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">AVL Tree + Boyer‚ÄìMoore</div>
                        <div class="info-sub">
                         AVL keeps the search tree balanced, so searching, inserting, or deleting any resource takes O(log n) time even when the library grows large.Boyer‚ÄìMoore is efficient for pattern matching in text, as it skips multiple characters at once, making keyword search inside long descriptions fast.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 4 ‚Äì Quality Education</div>
                        <div class="info-sub">
                       Faster access to knowledge and research material supports better learning and education.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> #include <bits/stdc++.h>
using namespace std;

struct AVLNode {
    string key;          // e.g. book or resource title
    int height;
    AVLNode *left;
    AVLNode *right;

    AVLNode(const string &k)
        : key(k), height(1), left(nullptr), right(nullptr) {}
};

int getHeight(AVLNode *node) {
    return node ? node->height : 0;
}

int getBalance(AVLNode *node) {
    if (!node) return 0;
    return getHeight(node->left) - getHeight(node->right);
}

AVLNode* rotateRight(AVLNode *y) {
    AVLNode *x = y->left;
    AVLNode *T2 = x->right;

    // Perform rotation
    x->right = y;
    y->left = T2;

    // Update heights
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

    return x; // new root
}

AVLNode* rotateLeft(AVLNode *x) {
    AVLNode *y = x->right;
    AVLNode *T2 = y->left;

    // Perform rotation
    y->left = x;
    x->right = T2;

    // Update heights
    x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
    y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

    return y; // new root
}

AVLNode* insertNode(AVLNode *node, const string &key) {
    // 1. Normal BST insertion
    if (!node) return new AVLNode(key);

    if (key < node->key)
        node->left = insertNode(node->left, key);
    else if (key > node->key)
        node->right = insertNode(node->right, key);
    else
        return node; // duplicate titles ignored or handle separately

    // 2. Update height
    node->height = 1 + max(getHeight(node->left), getHeight(node->right));

    // 3. Get balance factor
    int balance = getBalance(node);

    // 4. Balance the tree

    // Left Left Case
    if (balance > 1 && key < node->left->key)
        return rotateRight(node);

    // Right Right Case
    if (balance < -1 && key > node->right->key)
        return rotateLeft(node);

    // Left Right Case
    if (balance > 1 && key > node->left->key) {
        node->left = rotateLeft(node->left);
        return rotateRight(node);
    }

    // Right Left Case
    if (balance < -1 && key < node->right->key) {
        node->right = rotateRight(node->right);
        return rotateLeft(node);
    }

    // already balanced
    return node;
}

// Simple search for exact title
bool searchTitle(AVLNode *root, const string &key) {
    if (!root) return false;
    if (key == root->key) return true;
    if (key < root->key) return searchTitle(root->left, key);
    return searchTitle(root->right, key);
}

// Example usage
int main() {
    AVLNode *root = nullptr;

    // Insert some resource titles
    root = insertNode(root, "Smart Parking in Velora");
    root = insertNode(root, "Green Energy Management");
    root = insertNode(root, "Waste Collection Optimization");
    root = insertNode(root, "Transit Scheduling in Velora");

    string query;
    cout << "Enter title to search: ";
    getline(cin, query);

    if (searchTitle(root, query))
        cout << "Resource found in Knowledge Hub.\n";
    else
        cout << "Resource not found.\n";

    return 0;
}
 </pre>
                </div>
            </section>
            <!-- ========== CASE 13 (Segment Tree) ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 13</span>
                    <span class="case-pill"> Public transport inside Velora</span>
                </div>
                <div class="case-title">Velora Shuttle Fare & Route Planner</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora runs internal shuttle buses between different zones (hostels, labs, exhibitions, parking areas). The system must suggest cheap and safe routes for passengers and also handle special discounts or penalties on certain routes.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each stop in Velora is a node, and every road between stops has a cost (time, fare, or fuel usage). Sometimes some routes have discounts (negative cost edges, like ‚Äúearly morning discount‚Äù) or additional penalties (like ‚Äútemporary congestion charge‚Äù). The planner needs to compute the best route from a given source stop to all other stops considering these adjustments.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Bellman‚ÄìFord + Segment Tree + Floyd‚ÄìWarshall </div>
                        <div class="info-sub">
                       Bellman‚ÄìFord : Used for single-source shortest path where edges can have negative weights.Segment Tree : Used to manage and update fare or crowd levels over time ranges efficiently. Floyd‚ÄìWarshall : Used if Velora wants an all-pairs distance matrix between all stops, so at any time you can look up the best route between any two zones directly. 
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities and Communities</div>
                        <div class="info-sub">
                      Better public transit planning reduces congestion and supports eco-friendly mobility.
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> #include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v;
    int w; // cost: time / fare (can be negative for discount)
};

int main() {
    int n, m, src;
    cout << "Enter number of stops (vertices): ";
    cin >> n;
    cout << "Enter number of roads (edges): ";
    cin >> m;

    vector<Edge> edges(m);

    cout << "Enter edges as: from to cost\n";
    for (int i = 0; i < m; ++i) {
        cin >> edges[i].u >> edges[i].v >> edges[i].w;
    }

    cout << "Enter source stop: ";
    cin >> src;

    const int INF = 1e9;
    vector<int> dist(n + 1, INF);
    dist[src] = 0;

    // Relax edges (n - 1) times
    for (int i = 1; i <= n - 1; ++i) {
        bool changed = false;
        for (const auto &e : edges) {
            if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
                dist[e.v] = dist[e.u] + e.w;
                changed = true;
            }
        }
        if (!changed) break; // no change => already optimal
    }

    // Check for negative-weight cycle
    bool hasNegativeCycle = false;
    for (const auto &e : edges) {
        if (dist[e.u] != INF && dist[e.u] + e.w < dist[e.v]) {
            hasNegativeCycle = true;
            break;
        }
    }

    if (hasNegativeCycle) {
        cout << "Warning: Negative cycle detected in Velora shuttle network!\n";
    } else {
        cout << "Shortest cost from stop " << src << " to others:\n";
        for (int i = 1; i <= n; ++i) {
            cout << "Stop " << i << ": ";
            if (dist[i] == INF) cout << "unreachable\n";
            else cout << dist[i] << "\n";
        }
    }

    return 0;
} </pre>
                </div>
            </section>
  <!-- ========== CASE 14 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 14</span>
                    <span class="case-pill">  </span>
                </div>
                <div class="case-title">Emergency Vehicle Dispatch Sorting</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Velora‚Äôs emergency control room receives multiple distress calls with different severity scores. They must be arranged in correct order so ambulances or fire units are dispatched efficiently.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Each call has a severity value (1‚Äì10). To plan dispatch order, the system sorts all active calls from highest severity to lowest before allocating rescue units.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Merge Sort</div>
                        <div class="info-sub">
                           Merge Sort gives O(n log n) performance and remains fast even for large lists of emergency calls. It is stable and predictable, ensuring emergencies are ranked accurately.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 ‚Äì Good Health and Well-Being, SDG 11 ‚Äì Sustainable Cities</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // CASE 12: Emergency Vehicle Dispatch Sorting using Merge Sort
#include <bits/stdc++.h>
using namespace std;

struct Call {
    string id;
    int severity;
};

void mergeArr(vector<Call> &arr, int l, int m, int r) {
    vector<Call> left(arr.begin() + l, arr.begin() + m + 1);
    vector<Call> right(arr.begin() + m + 1, arr.begin() + r + 1);

    int i = 0, j = 0, k = l;

    while (i < left.size() && j < right.size()) {
        // Sort by severity (high ‚Üí low)
        if (left[i].severity >= right[j].severity)
            arr[k++] = left[i++];
        else
            arr[k++] = right[j++];
    }
    while (i < left.size()) arr[k++] = left[i++];
    while (j < right.size()) arr[k++] = right[j++];
}

void mergeSort(vector<Call> &arr, int l, int r) {
    if (l >= r) return;
    int m = (l + r) / 2;
    mergeSort(arr, l, m);
    mergeSort(arr, m + 1, r);
    mergeArr(arr, l, m, r);
}

int main() {
    int n;
    cout << "Enter number of emergency calls: ";
    cin >> n;

    vector<Call> calls(n);
    cout << "Enter CallID and Severity:\n";
    for (int i = 0; i < n; i++)
        cin >> calls[i].id >> calls[i].severity;

    mergeSort(calls, 0, n - 1);

    cout << "\nDispatch Order (Highest Severity First):\n";
    for (auto &c : calls)
        cout << c.id << " - Severity " << c.severity << "\n";

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 15 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 15</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Shuttle Boarding Reorder</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>boarding queue for shuttles.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Mostly near-sorted because passengers generally queue in arrival order but occasionally VIPs or reorders appear. The system must quickly reorder a small portion (fast incremental updates) and occasionally fully re-sort the list.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Quick + Selection + Bubble</div>
                        <div class="info-sub">
                          Quick Sort ‚Üí for fast large-size ordering (peak hours)

Selection Sort ‚Üí when exact position-based comparison is needed

Bubble Sort ‚Üí for minor adjustments (few misplaced passengers)
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äì Sustainable Cities & Communities, SDG 11 ‚Äì Sustainable Cities & Communities, SDG 8 ‚Äì Decent Work & Economic Growth</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // Case B: Shuttle Boarding Reorder (QuickSort primary; Selection for top-k promotions; Bubble for tiny local fixes)
#include <bits/stdc++.h>
using namespace std;

struct Passenger {
    string id;
    int vipScore;   // higher = more priority to board
    long long arrival; // arrival timestamp
};

// comparator: VIP first (desc), then earlier arrival
bool cmpPassenger(const Passenger &a, const Passenger &b) {
    if (a.vipScore != b.vipScore) return a.vipScore > b.vipScore;
    return a.arrival < b.arrival;
}

// --- QuickSort (in-place) ---
int partitionQuick(vector<Passenger> &arr, int l, int r) {
    Passenger pivot = arr[r];
    int i = l - 1;
    for (int j = l; j < r; ++j) {
        if (cmpPassenger(arr[j], pivot)) {
            ++i; swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[r]);
    return i + 1;
}

void quickSort(vector<Passenger> &arr, int l, int r) {
    if (l >= r) return;
    int pi = partitionQuick(arr, l, r);
    quickSort(arr, l, pi - 1);
    quickSort(arr, pi + 1, r);
}

// --- Selection to promote top-k VIP into front (stable extraction using simple scan) ---
void promoteTopK(vector<Passenger> &arr, int k) {
    if (k <= 0) return;
    int n = arr.size();
    k = min(k, n);
    // selection-like: for i in [0..k-1], find best in [i..n-1] and bring to i
    for (int i = 0; i < k; ++i) {
        int best = i;
        for (int j = i + 1; j < n; ++j) {
            if (cmpPassenger(arr[j], arr[best])) best = j;
        }
        // rotate to keep relative order for others (stable-ish)
        Passenger temp = arr[best];
        for (int t = best; t > i; --t) arr[t] = arr[t - 1];
        arr[i] = temp;
    }
}

// --- Tiny bubble pass to fix local small disorder (for near-sorted updates) ---
void tinyBubbleFix(vector<Passenger> &arr, int maxPasses = 2) {
    int n = arr.size();
    for (int pass = 0; pass < maxPasses; ++pass) {
        bool swapped = false;
        for (int i = 0; i + 1 < n; ++i) {
            if (!cmpPassenger(arr[i], arr[i + 1])) {
                swap(arr[i], arr[i + 1]);
                swapped = true;
            }
        }
        if (!swapped) break;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cout << "Enter number of passengers in queue: ";
    if (!(cin >> n) || n <= 0) return 0;

    vector<Passenger> q;
    q.reserve(n);
    for (int i = 0; i < n; ++i) {
        Passenger p;
        cin >> p.id >> p.vipScore >> p.arrival; // e.g.: P123 5 1672531200
        q.push_back(p);
    }

    cout << "\nOptions:\n1) Tiny local fix (bubble)\n2) Promote top-k VIPs\n3) Full reorder (QuickSort)\n4) Print queue\n5) Exit\n";

    while (true) {
        cout << "\nChoice: ";
        int ch; cin >> ch;
        if (ch == 1) {
            tinyBubbleFix(q, 2);
            cout << "Applied tiny bubble fix.\n";
        } else if (ch == 2) {
            int k; cout << "Enter k (number to promote): "; cin >> k;
            promoteTopK(q, k);
            cout << "Promoted top-" << k << " VIPs to front.\n";
        } else if (ch == 3) {
            quickSort(q, 0, (int)q.size() - 1);
            cout << "Full reorder done with QuickSort.\n";
        } else if (ch == 4) {
            cout << "\nCurrent queue order:\n";
            for (int i = 0; i < (int)q.size(); ++i) {
                cout << i + 1 << ". " << q[i].id
                     << " (vip=" << q[i].vipScore
                     << ", arrival=" << q[i].arrival << ")\n";
            }
        } else if (ch == 5) break;
        else cout << "Invalid.\n";
    }

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 16 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 16</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Campus Shuttle Stop Load Balancing</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>In a large campus like Velora Tech Park, every shuttle stop receives passengers at different rates each hour. The system must sort stops by crowd size so extra shuttles can be dispatched to the busiest ones.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Passenger counts are collected from sensors every 5 minutes and stored in a simple lookup table keyed by stop ID. The system then sorts the stops by load so the transport operator can prioritize which stops need immediate shuttle reinforcement.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Heap Sort, Lookup Table </div>
                        <div class="info-sub">
                            Heap Sort ‚Äî For Sorting Stops by Crowd Size
                          Lookup Table ‚Äî For Fast Stop Information Access
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main"> SDG 11 ‚Äî Sustainable Cities and Communities

SDG 9 ‚Äî Industry, Innovation and Infrastructure

SDG 13 ‚Äî Climate Action </div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // shuttle_load_balancer.cpp
// C++17 - In-place Heap Sort + Lookup Table example for Campus Shuttle Stop Load Balancing

#include <bits/stdc++.h>
using namespace std;

struct StopInfo {
    int id;
    string name;
    string zone;
    string next_shuttle_time; // e.g. "12:05"
    // add more metadata as needed
};

struct StopLoad {
    int id;
    int count; // current passenger count (window)
};

// --- Lookup table: stopID -> StopInfo
using StopLookup = unordered_map<int, StopInfo>;

// ---------------------- Heap Sort (in-place) ----------------------
// We'll sort vector<StopLoad> in descending order of count (largest first)
// Implementation: build max-heap then extract

void heapify(vector<StopLoad> &arr, int n, int i) {
    int largest = i;
    int l = 2*i + 1;
    int r = 2*i + 2;

    if (l < n && arr[l].count > arr[largest].count)
        largest = l;
    if (r < n && arr[r].count > arr[largest].count)
        largest = r;

    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSortDescending(vector<StopLoad> &arr) {
    int n = (int)arr.size();
    // Build max-heap
    for (int i = n/2 - 1; i >= 0; --i)
        heapify(arr, n, i);

    // Extract elements from heap one by one
    for (int i = n - 1; i > 0; --i) {
        // Move current root (largest) to end
        swap(arr[0], arr[i]);
        // call heapify on reduced heap
        heapify(arr, i, 0);
    }
    // After this, array is sorted in ascending order by count.
    // We want descending (largest first) so reverse:
    reverse(arr.begin(), arr.end());
}

// ---------------------- Business logic helpers ----------------------

void printTopK(const vector<StopLoad> &sortedLoads, const StopLookup &lookup, int K) {
    cout << "Top " << K << " busiest stops:\n";
    for (int i = 0; i < (int)sortedLoads.size() && i < K; ++i) {
        int id = sortedLoads[i].id;
        int cnt = sortedLoads[i].count;
        auto it = lookup.find(id);
        if (it != lookup.end()) {
            const StopInfo &s = it->second;
            cout << i+1 << ". StopID: " << s.id << " | " << s.name << " | Zone: " << s.zone
                 << " | Load: " << cnt << " | Next shuttle: " << s.next_shuttle_time << "\n";
        } else {
            cout << i+1 << ". StopID: " << id << " | Load: " << cnt << " | (metadata missing)\n";
        }
    }
    cout << "----\n";
}

// Simulate sensor updates: this updates the current counts map (every 5 minutes in reality)
void applySensorUpdates(unordered_map<int,int> &currentCounts, const vector<pair<int,int>> &updates) {
    // updates: vector of (stopID, measuredCount)
    for (auto &u : updates) {
        currentCounts[u.first] = u.second; // overwrite with latest window count
    }
}

// Convert currentCounts map to vector<StopLoad>
vector<StopLoad> buildLoadVector(const unordered_map<int,int> &currentCounts, const StopLookup &lookup) {
    vector<StopLoad> loads;
    loads.reserve(currentCounts.size());
    for (auto &p : currentCounts) {
        loads.push_back({p.first, p.second});
    }
    // optional: ensure all stops exist in lookup (if some are missing, we still include them)
    return loads;
}

// Example dispatch recommendation: choose top K stops and print a recommendation
void recommendDispatch(const vector<StopLoad> &sortedLoads, const StopLookup &lookup, int K) {
    cout << "Dispatch recommendation (send extra shuttle to these stops):\n";
    for (int i = 0; i < (int)sortedLoads.size() && i < K; ++i) {
        int id = sortedLoads[i].id;
        auto it = lookup.find(id);
        string label = (it != lookup.end()) ? it->second.name : ("Stop " + to_string(id));
        cout << "- " << label << " (ID " << id << ") : current load = " << sortedLoads[i].count << "\n";
    }
    cout << "====\n";
}

// ---------------------- Main (demo) ----------------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Build lookup table (would be static / persisted in real system)
    StopLookup lookup;
    lookup[101] = {101, "North Gate", "Zone A", "12:05"};
    lookup[102] = {102, "Library", "Zone B", "12:10"};
    lookup[103] = {103, "Cafeteria", "Zone C", "12:00"};
    lookup[104] = {104, "South Gate", "Zone D", "12:20"};
    lookup[105] = {105, "Research Park", "Zone E", "12:15"};
    lookup[106] = {106, "Admin Block", "Zone B", "12:12"};

    // Current counts keyed by stopID (updated every 5 minutes by sensors)
    unordered_map<int,int> currentCounts;
    // initialize with zeros
    for (auto &kv : lookup) currentCounts[kv.first] = 0;

    // Simulate multiple 5-minute sensor updates (normally this would be event driven)
    vector<vector<pair<int,int>>> sensorBatches = {
        // batch 1 (t0)
        { {101, 5}, {102, 12}, {103, 9}, {104, 3}, {105, 20}, {106, 7} },
        // batch 2 (t+5min)
        { {101, 8}, {102, 18}, {103, 6}, {104, 4}, {105, 22}, {106, 5} },
        // batch 3 (t+10min)
        { {101, 10}, {102, 25}, {103, 15}, {104, 6}, {105, 12}, {106, 9} }
    };

    int topK = 3;

    for (size_t t = 0; t < sensorBatches.size(); ++t) {
        cout << "\n[Sensor batch " << (t+1) << "] Applying 5-minute updates...\n";
        applySensorUpdates(currentCounts, sensorBatches[t]);

        // Create vector from counts and sort using heap sort
        vector<StopLoad> loads = buildLoadVector(currentCounts, lookup);
        heapSortDescending(loads);

        // Print top-K and recommend dispatch
        printTopK(loads, lookup, topK);
        recommendDispatch(loads, lookup, topK);

        // In real system, here we'd trigger an event to dispatch extra shuttle(s)
        // or update operator dashboard.
    }

    return 0;
}</pre>
                </div>
            </section>

 <!-- ========== CASE 17 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 17</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Emergency Evacuation Path Finder</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>boarding queue for shuttles.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Mostly near-sorted because passengers generally queue in arrival order but occasionally VIPs or reorders appear. The system must quickly reorder a small portion (fast incremental updates) and occasionally fully re-sort the list.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">DFS + Backtracking + Dynamic Programming</div>
                        <div class="info-sub">
                         DFS explores the building layout thoroughly.

Backtracking helps avoid dead-ends and unsafe areas.

Dynamic Programming picks the safest and quickest final path among many.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 ‚Äî Sustainable Cities and Communities

SDG 3 ‚Äî Good Health and Well-being

SDG 9 ‚Äî Industry, Innovation and Infrastructure

SDG 13 ‚Äî Climate Action</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// evac_pathfinder.cpp
// C++17 - Emergency Evacuation Path Finder (DFS + Backtracking + DP + Fire spread BFS)

#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;
struct Pos { int r, c; };
struct Node { int r, c, t; };

// 4-neighbour moves (up, right, down, left)
const vector<pair<int,int>> DIRS = {{-1,0},{0,1},{1,0},{0,-1}};

// Utility
bool inside(int r, int c, int R, int C) { return r>=0 && r<R && c>=0 && c<C; }

// Compute earliest fire arrival times using multi-source BFS
// grid: 0 = free, 1 = wall/blocked
// fireSources: list of starting fire positions (they get fire at time 0)
// fireSpreadTimePerStep: time it takes fire to spread across one cell (int)
vector<vector<int>> computeFireTimes(const vector<vector<int>>& grid,
                                     const vector<Pos>& fireSources,
                                     int fireSpreadTimePerStep) {
    int R = grid.size(), C = grid[0].size();
    vector<vector<int>> fireTime(R, vector<int>(C, INF));
    deque<Node> dq;
    for (auto &fs : fireSources) {
        if (inside(fs.r, fs.c, R, C) && grid[fs.r][fs.c] == 0) {
            fireTime[fs.r][fs.c] = 0;
            dq.push_back({fs.r, fs.c, 0});
        }
    }
    while (!dq.empty()) {
        Node cur = dq.front(); dq.pop_front();
        for (auto &d : DIRS) {
            int nr = cur.r + d.first, nc = cur.c + d.second;
            if (!inside(nr,nc,R,C)) continue;
            if (grid[nr][nc] == 1) continue; // wall/blocked cannot be burned/traversed
            int arrive = cur.t + fireSpreadTimePerStep;
            if (arrive < fireTime[nr][nc]) {
                fireTime[nr][nc] = arrive;
                dq.push_back({nr,nc,arrive});
            }
        }
    }
    return fireTime;
}

// DFS with backtracking + DP to find minimal safe evacuation time path
// - start: starting position and startTime (time when person is at start)
// - exits: set of exit positions (any of these are valid goal)
// - moveTimePerStep: time taken by person to move between adjacent cells
// Rules to consider a move safe:
//   when person would arrive at a cell at time T_person, it's safe only if T_person < fireTime[cell]
//   (if T_person == fireTime[cell], consider unsafe; adjust as policy)
// Returns tuple (found, bestTime, bestPath)
tuple<bool,int,vector<Pos>> findFastestSafePathDFS(const vector<vector<int>>& grid,
                                                  const vector<vector<int>>& fireTime,
                                                  Pos start, int startTime,
                                                  const vector<Pos>& exits,
                                                  int moveTimePerStep) {
    int R = grid.size(), C = grid[0].size();
    vector<vector<int>> bestTime(R, vector<int>(C, INF)); // DP: best known time to reach cell
    vector<Pos> path, bestPath;
    bool found = false;
    int bestArrival = INF;

    // exit quick-lookup
    vector<vector<bool>> isExit(R, vector<bool>(C, false));
    for (auto &e : exits) if (inside(e.r,e.c,R,C)) isExit[e.r][e.c] = true;

    function<void(int,int,int)> dfs = [&](int r, int c, int curTime) {
        // Prune if current time already worse than best overall
        if (curTime >= bestArrival) return;
        // Prune using DP: if we've been here earlier (<=) then no point
        if (curTime >= bestTime[r][c]) return;
        bestTime[r][c] = curTime;

        // If cell will be on fire at or before arrival, cannot be here
        if (curTime >= fireTime[r][c]) return;

        // Add to path
        path.push_back({r,c});

        // If this is an exit, record solution
        if (isExit[r][c]) {
            found = true;
            if (curTime < bestArrival) {
                bestArrival = curTime;
                bestPath = path;
            }
            // still backtrack (there might be faster through other branches)
            path.pop_back();
            return;
        }

        // Explore neighbors
        for (auto &d : DIRS) {
            int nr = r + d.first, nc = c + d.second;
            if (!inside(nr,nc,R,C)) continue;
            if (grid[nr][nc] == 1) continue; // wall/blocked
            int arriveTime = curTime + moveTimePerStep;
            // Only attempt if arriveTime < fireTime[nr][nc]
            if (arriveTime >= fireTime[nr][nc]) continue;
            // Also prune if arriveTime >= bestArrival
            if (arriveTime >= bestArrival) continue;
            dfs(nr, nc, arriveTime);
        }

        // backtrack
        path.pop_back();
    };

    // Start: check start isn't immediately on fire and not wall
    if (!inside(start.r,start.c,R,C) || grid[start.r][start.c] == 1) {
        return {false, INF, {}};
    }
    if (startTime >= fireTime[start.r][start.c]) {
        // Person cannot start safely
        return {false, INF, {}};
    }

    dfs(start.r, start.c, startTime);
    return {found, bestArrival, bestPath};
}

// Helper to print path
void printPath(const vector<Pos>& path) {
    for (size_t i=0;i<path.size();++i) {
        cout << "(" << path[i].r << "," << path[i].c << ")";
        if (i+1<path.size()) cout << " -> ";
    }
    cout << "\n";
}

// Demo main with an example grid
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Grid legend:
    // 0 = free cell (room/corridor)
    // 1 = wall / blocked / collapsed (never traversable)
    // We'll show a 8x10 example building floor
    vector<vector<int>> grid = {
        {0,0,0,0,0,1,0,0,0,0},
        {0,1,1,0,0,1,0,1,1,0},
        {0,0,0,0,0,0,0,1,0,0},
        {0,1,0,1,1,0,0,0,0,0},
        {0,1,0,0,0,0,1,1,1,0},
        {0,0,0,1,0,0,0,0,0,0},
        {1,1,0,1,0,1,1,0,1,0},
        {0,0,0,0,0,0,0,0,0,0}
    };
    int R = grid.size(), C = grid[0].size();

    // Fire sources (cells where fire starts at t=0)
    vector<Pos> fireSources = { {0,9}, {4,4} }; // example: fire in top-right corner and middle
    int fireSpreadPerStep = 2; // fire spreads to adjacent cell in 2 time units

    // Person start and exits
    Pos start = {7, 0}; // bottom-left
    vector<Pos> exits = { {0,0}, {0,4}, {7,9} }; // top-left, a mid-top exit, and bottom-right

    // Person movement time per step
    int moveTime = 1; // person takes 1 time unit to move across one cell

    // Starting time (person at start at this time)
    int startTime = 0;

    // Step 1: compute fire arrival times
    auto fireTime = computeFireTimes(grid, fireSources, fireSpreadPerStep);

    // debug: print fire times grid (INF -> "X")
    cout << "Fire arrival times (INF = safe forever / unreachable by fire):\n";
    for (int r=0;r<R;++r) {
        for (int c=0;c<C;++c) {
            if (grid[r][c] == 1) {
                cout << "  # "; // wall
            } else {
                if (fireTime[r][c] >= INF) cout << "  X ";
                else {
                    // align numbers
                    cout << setw(3) << fireTime[r][c] << " ";
                }
            }
        }
        cout << "\n";
    }
    cout << "----\n";

    // Step 2: run DFS/backtracking with DP to find fastest safe path
    auto [found, bestArrival, bestPath] = findFastestSafePathDFS(grid, fireTime, start, startTime, exits, moveTime);

    if (!found) {
        cout << "No safe evacuation path found from start (" << start.r << "," << start.c << ").\n";
    } else {
        cout << "Fastest safe evacuation found. Arrival time: " << bestArrival << "\n";
        cout << "Path (coordinates): ";
        printPath(bestPath);
        // Also print timeline: time at each step
        cout << "Timeline:\n";
        int t = startTime;
        for (size_t i=0;i<bestPath.size();++i) {
            cout << " t=" << setw(3) << t << " -> (" << bestPath[i].r << "," << bestPath[i].c << ")";
            if (t >= fireTime[bestPath[i].r][bestPath[i].c]) cout << "  [ON FIRE]";
            cout << "\n";
            if (i+1 < bestPath.size()) t += moveTime;
        }
    }

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 18 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 18</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Industrial Parts Catalogue Indexing</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Factories maintain a catalog of thousands of parts used in machinery. The system must store parts by ID, name, and category while guaranteeing balanced search performance.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Items are frequently inserted and searched by maintenance staff. A balanced tree ensures consistent O(log n) response time even with large catalogs.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Red-Black Tree + 2-3 Tree + Divide & Conquer</div>
                        <div class="info-sub">
                         Red-Black Trees provide fast insertions in real time. 
2-3 Trees support guaranteed height balancing, ideal for large catalogs.
Divide & Conquer ensures efficient batch processing.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 9 ‚Äî Industry, Innovation and Infrastructure

SDG 8 ‚Äî Decent Work and Economic Growth

SDG 12 ‚Äî Responsible Consumption and Production</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // parts_catalog.cpp
// C++17 - CASE D: Industrial Parts Catalogue Indexing
// - dynamic catalog: std::map (RB-tree under the hood)
// - static catalog: custom 2-3 tree built via divide & conquer

#include <bits/stdc++.h>
using namespace std;

// -------------------------------
// Domain type: Part
// -------------------------------
struct Part {
    long long id;       // unique numeric ID (key)
    string name;
    string category;

    bool operator<(const Part& o) const {
        return id < o.id;
    }
};

// pretty print
ostream& operator<<(ostream& os, const Part &p) {
    os << "[ID:" << p.id << ", " << p.name << ", " << p.category << "]";
    return os;
}

// -------------------------------
// RED-BLACK TREE (dynamic) USING std::map
// std::map is typically implemented as a red-black tree and provides O(log n)
// -------------------------------
class DynamicCatalog {
    // map from id -> Part (std::map gives balanced tree behavior)
    std::map<long long, Part> table;
public:
    void insert(const Part &p) {
        table[p.id] = p; // insert or update
    }

    bool remove(long long id) {
        auto it = table.find(id);
        if (it == table.end()) return false;
        table.erase(it);
        return true;
    }

    optional<Part> find(long long id) const {
        auto it = table.find(id);
        if (it == table.end()) return nullopt;
        return it->second;
    }

    size_t size() const { return table.size(); }

    // iterate
    template<typename Fn>
    void forEach(Fn fn) const {
        for (auto &kv : table) fn(kv.second);
    }
};

// -------------------------------
// 2-3 TREE (static) implementation
// Node stores either one key (2-node) or two keys (3-node).
// This is a minimal educational implementation supporting build/search.
// -------------------------------
class TwoThreeTree {
public:
    struct Node {
        // For simplicity: store keys as Part and use id as comparison
        // keys size = 1 (2-node) or 2 (3-node)
        vector<Part> keys;
        vector<Node*> children; // 0 for leaf, otherwise children.size() == keys.size()+1

        Node() {}
        ~Node() {
            for (auto c : children) delete c;
        }
        bool isLeaf() const { return children.empty(); }
    };

private:
    Node *root = nullptr;

    // Build a balanced 2-3 tree from a sorted vector of Parts using divide & conquer.
    // Strategy (simple and deterministic):
    // - If vector small, create leaf node with 1 or 2 keys.
    // - Otherwise split into 3 near-equal parts and create internal node with 1 or 2 keys taken
    //   as separators, recursively build children.
    Node* buildFromSorted(const vector<Part>& items, int L, int R) {
        int n = R - L;
        if (n <= 0) return nullptr;
        if (n == 1) {
            Node* node = new Node();
            node->keys.push_back(items[L]);
            return node;
        }
        if (n == 2) {
            Node* node = new Node();
            node->keys.push_back(items[L]);
            node->keys.push_back(items[L+1]);
            return node;
        }

        // For n >= 3, split into 3 blocks as evenly as possible
        int third = n / 3;
        if (third == 0) third = 1;
        int a = L;
        int b = min(R, a + third);
        int c = min(R, b + third);

        // If remaining is large, adjust to ensure we have meaningful partitions
        if (R - c <= third/2) {
            // simple fallback: split in two parts (create a 2-node)
            int mid = L + n/2;
            Node* node = new Node();
            node->keys.push_back(items[mid]);
            node->children.push_back(buildFromSorted(items, L, mid));
            node->children.push_back(buildFromSorted(items, mid+1, R));
            // clean null children
            vector<Node*> ch;
            for (auto p : node->children) if (p) ch.push_back(p);
            node->children.swap(ch);
            return node;
        }

        // Create an internal 3-node:
        // choose separators k1 = items[b-1], k2 = items[c-1] (safe because b-1 >= a)
        Node* node = new Node();
        node->keys.push_back(items[b-1]);
        node->keys.push_back(items[c-1]);
        // children: [L..b-1), [b-1..c-1), [c-1..R)
        node->children.push_back(buildFromSorted(items, L, b-1));
        node->children.push_back(buildFromSorted(items, b-1, c-1));
        node->children.push_back(buildFromSorted(items, c-1, R));
        // remove empty children
        vector<Node*> ch;
        for (auto p : node->children) if (p) ch.push_back(p);
        node->children.swap(ch);
        return node;
    }

    // Search helper
    const Part* searchNode(Node* node, long long id) const {
        if (!node) return nullptr;
        // check keys
        for (auto &k : node->keys) {
            if (k.id == id) return &k;
        }
        if (node->isLeaf()) return nullptr;
        // choose child
        // keys are 1 or 2, children size accordingly
        if (node->keys.size() == 1) {
            if (id < node->keys[0].id) return searchNode(node->children[0], id);
            else return searchNode(node->children[1], id);
        } else {
            // two keys
            if (id < node->keys[0].id) return searchNode(node->children[0], id);
            else if (id < node->keys[1].id) return searchNode(node->children[1], id);
            else return searchNode(node->children[2], id);
        }
    }

public:
    TwoThreeTree() {}
    ~TwoThreeTree() { delete root; }

    // Build from arbitrary vector by sorting then divide & conquer.
    void buildFromVector(vector<Part> items) {
        if (root) { delete root; root = nullptr; }
        sort(items.begin(), items.end(), [](const Part&a,const Part&b){ return a.id < b.id; });
        root = buildFromSorted(items, 0, (int)items.size());
    }

    optional<Part> find(long long id) const {
        const Part* p = searchNode(root, id);
        if (!p) return nullopt;
        return *p;
    }

    // debug printing (in-order)
    void inorderDump() const {
        function<void(Node*)> dfs = [&](Node* node) {
            if (!node) return;
            if (node->isLeaf()) {
                for (auto &k : node->keys) cout << k << "\n";
            } else {
                if (node->keys.size() == 1) {
                    dfs(node->children[0]);
                    cout << node->keys[0] << "\n";
                    dfs(node->children[1]);
                } else {
                    dfs(node->children[0]);
                    cout << node->keys[0] << "\n";
                    dfs(node->children[1]);
                    cout << node->keys[1] << "\n";
                    dfs(node->children[2]);
                }
            }
        };
        dfs(root);
    }
};

// -------------------------------
// Divide & Conquer Bulk Import Utilities
// -------------------------------
// Example: split a large dataset into chunks and build per-chunk 2-3 trees in parallel (conceptually).
// Here we'll simply demonstrate splitting and building multiple 2-3 trees (vector of trees).
vector<TwoThreeTree> divideAndBuildChunks(const vector<Part>& allParts, int chunks) {
    vector<TwoThreeTree> trees;
    if (allParts.empty() || chunks <= 0) return trees;
    int n = allParts.size();
    int per = max(1, n / chunks);
    for (int i = 0; i < n; i += per) {
        int j = min(n, i + per);
        vector<Part> slice(allParts.begin() + i, allParts.begin() + j);
        TwoThreeTree t;
        t.buildFromVector(move(slice));
        trees.push_back(std::move(t));
    }
    return trees;
}

// -------------------------------
// Demo main
// -------------------------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Sample parts (unsorted)
    vector<Part> sample = {
        {1003, "Coupling - A", "Mechanical"},
        {1001, "Bolt M8x30", "Fasteners"},
        {1010, "Bearing - 6204", "Mechanical"},
        {1007, "Filter - Oil", "Consumables"},
        {1002, "Nut M8", "Fasteners"},
        {1009, "Seal Ring", "Seals"},
        {1005, "Sprocket small", "Transmission"},
        {1008, "Gasket set", "Consumables"},
        {1004, "Washer M8", "Fasteners"},
        {1011, "Sensor temp", "Electronics"},
    };

    // -------------------------
    // Dynamic catalog usage (red-black via std::map)
    // -------------------------
    DynamicCatalog dyn;
    for (auto &p : sample) {
        dyn.insert(p);
    }
    cout << "Dynamic catalog size: " << dyn.size() << "\n";
    auto f = dyn.find(1007);
    if (f) cout << "Found dynamic: " << *f << "\n";
    else cout << "Not found dynamic id 1007\n";

    // Insert new live part
    dyn.insert({2000, "Emergency Valve", "Safety"});
    cout << "After live insert size: " << dyn.size() << "\n";

    // -------------------------
    // Static catalog build (2-3 tree) using divide & conquer
    // -------------------------
    TwoThreeTree staticCatalog;
    staticCatalog.buildFromVector(sample); // build (sort + divide & conquer)
    cout << "\nStatic catalog (2-3 tree) inorder dump:\n";
    staticCatalog.inorderDump();

    // Search static
    auto r = staticCatalog.find(1010);
    if (r) cout << "\nFound in static: " << *r << "\n";
    else cout << "\nNot found in static\n";

    // -------------------------
    // Bulk import example: divide into 3 chunks, build 3 trees
    // -------------------------
    vector<Part> big = sample;
    // emulate a larger data set by duplicating with new ids
    for (int i = 0; i < 200; ++i) {
        big.push_back({3000 + i, "Part_" + to_string(i), (i%2? "Mech":"Elec")});
    }
    auto builtChunks = divideAndBuildChunks(big, 4);
    cout << "\nBuilt " << builtChunks.size() << " chunked 2-3 trees (divide & conquer). Sizes (approx):\n";
    for (size_t i = 0; i < builtChunks.size(); ++i) {
        cout << " - chunk " << i << " (inorder sample):\n";
        // print first few items of each chunk by doing inorder dump but limit output
        // (we won't implement size query; this is just demo)
        builtChunks[i].inorderDump();
        cout << "----\n";
        if (i >= 0 && i >= 0) {
            // break early for readable demo; in real system you might keep them all
            // (comment the following to print all)
            break;
        }
    }

    // -------------------------
    // Example combined usage: dynamic updates + periodic static re-index
    // -------------------------
    // Workflow:
    // - Use DynamicCatalog for real-time inserts/updates (RB-tree properties)
    // - Once per week, dump dynamic catalog to vector, sort, and rebuild staticCatalog via buildFromVector
    // - staticCatalog serves fastest, balanced read-only queries for analytics / batch lookup
    cout << "\nExample: rebuild static catalog from current dynamic catalog (weekly):\n";
    vector<Part> dump;
    dyn.forEach([&](const Part &p){ dump.push_back(p); });
    staticCatalog.buildFromVector(dump);
    cout << "Rebuilt static catalog (size approx):\n";
    staticCatalog.inorderDump();

    cout << "\nDemo complete.\n";
    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 19 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 19</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Emergency Response Network</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Design the minimal-cost network of emergency service roads or dedicated lanes that connects all hospitals, fire stations and major junctions.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Given candidate road segments with construction/maintenance cost or travel-time weight, compute a subset connecting all critical facilities while minimizing total cost. This reduces redundancy and ensures emergency vehicles have a connected, low-cost backbone.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Kruskal‚Äôs algorithm (MST)</div>
                        <div class="info-sub">
picks smallest edges and merges components via union-find (DSU). Ideal when you have weighted edges and need a minimal-total-cost spanning network.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 3 (Good Health & Well-Being), SDG 9 (Industry, Innovation & Infrastructure)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // kruskal_mst.cpp
// Compile: g++ -std=c++17 -O2 kruskal_mst.cpp -o kruskal_mst
// Run: ./kruskal_mst < input.txt

#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int u, v;
    long long w;
    int idx; // optional original index
    bool operator<(Edge const& o) const {
        return w < o.w;
    }
};

struct DSU {
    int n;
    vector<int> p, r;
    DSU(int n=0){init(n);}
    void init(int N){ n=N; p.resize(N); r.assign(N,0); for(int i=0;i<N;++i)p[i]=i; }
    int find(int x){ return p[x]==x?x:p[x]=find(p[x]); }
    bool unite(int a,int b){
        a=find(a); b=find(b);
        if(a==b) return false;
        if(r[a]<r[b]) swap(a,b);
        p[b]=a;
        if(r[a]==r[b]) r[a]++;
        return true;
    }
    bool same(int a,int b){ return find(a)==find(b); }
};

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    // Input format:
    // N M
    // M lines: u v w
    // (nodes numbered 1..N in sample, code converts to 0..N-1)
    if(!(cin >> N >> M)){
        cerr << "Expected: N M followed by M edges.\n";
        return 1;
    }

    vector<Edge> edges;
    edges.reserve(M);
    for(int i=0;i<M;++i){
        int u,v; long long w;
        cin >> u >> v >> w;
        // allow 1-based or 0-based: if any index equals N, assume 1-based
        // but simple: assume user provides 1..N; convert to 0..N-1
        edges.push_back({u-1, v-1, w, i});
    }

    sort(edges.begin(), edges.end());

    DSU dsu(N);
    long long totalCost = 0;
    vector<Edge> chosen;
    chosen.reserve(N-1);

    for(const Edge &e : edges){
        if(dsu.unite(e.u, e.v)){
            chosen.push_back(e);
            totalCost += e.w;
            if((int)chosen.size() == N-1) break;
        }
    }

    // Check connectivity
    int rep = dsu.find(0);
    for(int i=1;i<N;i++){
        if(dsu.find(i) != rep){
            cout << "Graph is disconnected ‚Äî no spanning network covering all nodes.\n";
            return 0;
        }
    }

    cout << "MST total cost: " << totalCost << "\n";
    cout << "Edges in MST (u v w) (1-based nodes):\n";
    for(auto &e : chosen){
        cout << (e.u+1) << " " << (e.v+1) << " " << e.w << "\n";
    }
    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 20 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 20</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Dynamic Crowd Counters</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Live tracking of visitor counts per stall/gallery/zone with frequent point updates and prefix / cumulative queries.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Operators need to update counts as people enter/exit a small area and frequently ask queries like ‚Äúhow many visitors in first N stalls?‚Äù or ‚Äútotal visitors up to zone X‚Äù. Fenwick tree gives fast point updates and prefix sums.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Fenwick Tree / Binary Indexed Tree</div>
                        <div class="info-sub">
                     O(log n) updates and prefix queries with compact code and low memory.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 (Sustainable Cities & Communities), SDG 3 (Safety in public spaces)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// crowd_counter_fenwick.cpp
// Compile: g++ -std=c++17 -O2 crowd_counter_fenwick.cpp -o crowd_counter
// Run: ./crowd_counter

#include <bits/stdc++.h>
using namespace std;

class Fenwick {
    int n;
    vector<long long> bit;   // 1-indexed Fenwick tree
public:
    Fenwick(int n) : n(n), bit(n+1, 0) {}

    // Add value 'val' to index 'i' (1-indexed)
    void update(int i, long long val) {
        for (; i <= n; i += i & -i)
            bit[i] += val;
    }

    // Prefix sum query: sum of [1..i]
    long long query(int i) const {
        long long s = 0;
        for (; i > 0; i -= i & -i)
            s += bit[i];
        return s;
    }

    // Range sum: [l..r]
    long long rangeQuery(int l, int r) const {
        return query(r) - query(l - 1);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n = 10; // Example: 10 stalls/zones
    Fenwick fw(n);

    // Initial counts (could come from sensors)
    vector<int> initial = {5, 3, 10, 2, 7, 0, 6, 1, 4, 9}; // size = n

    // Build BIT from initial values
    for (int i = 0; i < n; ++i)
        fw.update(i + 1, initial[i]);

    // Example operations
    cout << "Total visitors in first 5 stalls: "
         << fw.query(5) << "\n";

    cout << "Visitors in stalls 3 to 7: "
         << fw.rangeQuery(3, 7) << "\n";

    // Live update: 4 visitors entered stall 2
    fw.update(2, 4);

    cout << "After update, prefix sum(5): "
         << fw.query(5) << "\n";

    // Live update: 3 visitors left stall 4
    fw.update(4, -3);

    cout << "Visitors in stalls 1..10: "
         << fw.query(10) << "\n";

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 21 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 21</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Sensor Analytics: Static Range Queries</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Historical analytics on environment sensors (temperature, noise) where data is written once and then many range-min/max queries are run.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Sensors produce large logs; analysts frequently ask ‚Äúwhat was the maximum pollution reading between time A and B?‚Äù Data is mostly static (append-only or batched). Sparse Table supports fast (O(1)) RMQ after O(n log n) preprocess.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Sparse Table</div>
                        <div class="info-sub">
                          Preprocess for idempotent functions (min/max/gcd) to answer range queries in O(1)
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 (Sustainable Cities), SDG 3 (Good Health)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // sparse_table_sensor.cpp
// C++17 - Sparse Table for RMQ (min or max) on static sensor logs
// Compile: g++ -std=c++17 -O2 sparse_table_sensor.cpp -o sparse_table_sensor
// Run: ./sparse_table_sensor

#include <bits/stdc++.h>
using namespace std;

struct SparseTable {
    int n;
    int LOG;                          // floor(log2(n))
    vector<int> lg;                   // precomputed logs
    // st[k][i] holds value for interval starting at i of length 2^k
    vector<vector<long long>> st;
    // aggregator: +1 => max, -1 => min (we use compare accordingly)
    int mode; // +1 for max, -1 for min

    // constructor: mode = +1 -> max, mode = -1 -> min
    SparseTable() : n(0), LOG(0), mode(+1) {}

    void build(const vector<long long>& a, int mode_in = +1) {
        mode = (mode_in >= 0 ? +1 : -1);
        n = (int)a.size();
        LOG = (n>0) ? 31 - __builtin_clz(n) : 0;
        lg.assign(n+1, 0);
        for (int i = 2; i <= n; ++i) lg[i] = lg[i/2] + 1;

        st.assign(LOG+1, vector<long long>(n));
        // k = 0
        for (int i = 0; i < n; ++i) st[0][i] = a[i];

        for (int k = 1; k <= LOG; ++k) {
            int len = 1 << k;
            int half = 1 << (k-1);
            for (int i = 0; i + len <= n; ++i) {
                long long left = st[k-1][i];
                long long right = st[k-1][i + half];
                if (mode == +1) st[k][i] = max(left, right);
                else st[k][i] = min(left, right);
            }
        }
    }

    // Query on inclusive range [l, r] (0-indexed)
    long long query(int l, int r) const {
        if (l > r) swap(l,r);
        int len = r - l + 1;
        int k = lg[len];
        long long left = st[k][l];
        long long right = st[k][r - (1<<k) + 1];
        if (mode == +1) return max(left, right);
        else return min(left, right);
    }
};

// ---------------- Demo ----------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    // Example sensor log (e.g., hourly pollution readings)
    vector<long long> pollution = {
        55, 60, 58, 63, 70, 68, 65, 59, 62, 61, 66, 64
    };

    // Build sparse tables for MIN and MAX (show both)
    SparseTable stMax, stMin;
    stMax.build(pollution, +1);  // max table
    stMin.build(pollution, -1);  // min table

    // Example queries (0-indexed): "max pollution between time A and B"
    vector<pair<int,int>> queries = {
        {0, 3},   // t=0..3
        {2, 6},   // t=2..6
        {4, 11},  // t=4..11
        {7, 9}    // t=7..9
    };

    cout << "Sensor data (index:value):\n";
    for (int i = 0; i < (int)pollution.size(); ++i)
        cout << i << ":" << pollution[i] << (i+1< (int)pollution.size() ? ", " : "\n");
    cout << "\n";

    for (auto &q : queries) {
        int l = q.first, r = q.second;
        cout << "Range [" << l << "," << r << "]: max = " << stMax.query(l,r)
             << ", min = " << stMin.query(l,r) << "\n";
    }

    // Typical usage in dashboards:
    // - preprocess once after data batch/append
    // - answer thousands of RMQ queries in O(1) each
    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 22 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 22</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Vendor Directory with Concurrency</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>An in-memory ordered vendor directory that supports concurrent insert/search/delete with probabilistic balancing.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>For a high-traffic vendor directory where many small updates and reads occur, skip list provides expected O(log n) operations and is easier to make lock-free than balanced trees in concurrent environments.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Skip list</div>
                        <div class="info-sub">
                         Skip List (probabilistic ordered structure) ‚Äî provides ordered map semantics with simpler concurrency support compared to complex balancing.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 8 (Decent Work & Economic Growth), SDG 9 (Innovation & Infrastructure)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // concurrent_skiplist.cpp
// C++17 - Concurrent Skip List (reader-writer lock via shared_mutex)
// Compile: g++ -std=c++17 -O2 concurrent_skiplist.cpp -pthread -o concurrent_skiplist
// Run: ./concurrent_skiplist

#include <bits/stdc++.h>
#include <shared_mutex>
using namespace std;

// Simple thread-safe skip list with shared_mutex: readers use shared_lock, writers use unique_lock.
// Not lock-free, but safer and much easier to implement and reason about than hand-rolled lock-free variants.

template<typename Key, typename Value>
class ConcurrentSkipList {
private:
    struct Node {
        Key key;
        Value val;
        vector<Node*> next;
        Node(int level, Key k = Key(), Value v = Value()) : key(k), val(v), next(level, nullptr) {}
    };

    const int MAX_LEVEL;
    const double P; // probability for random level
    Node* head;
    int level;   // current max level (0-indexed)
    mutable std::shared_mutex rwmutex; // protects structure for concurrency
    std::mt19937 rng;
    std::uniform_real_distribution<double> dist;

    int randomLevel() {
        int lvl = 1;
        while (lvl < MAX_LEVEL && dist(rng) < P) ++lvl;
        return lvl;
    }

public:
    ConcurrentSkipList(int maxLevel = 32, double probability = 0.5)
        : MAX_LEVEL(maxLevel), P(probability), level(1), rng(std::random_device{}()), dist(0.0, 1.0)
    {
        head = new Node(MAX_LEVEL, Key(), Value()); // sentinel head with MAX_LEVEL pointers
    }

    ~ConcurrentSkipList() {
        Node* cur = head;
        // delete nodes (single-threaded destruction)
        while (cur) {
            Node* nxt = cur->next[0];
            delete cur;
            cur = nxt;
        }
    }

    // Insert or update
    void insert(const Key& key, const Value& value) {
        std::unique_lock lock(rwmutex); // exclusive lock for writers

        vector<Node*> update(MAX_LEVEL, nullptr);
        Node* x = head;
        for (int i = level - 1; i >= 0; --i) {
            while (x->next[i] && x->next[i]->key < key) x = x->next[i];
            update[i] = x;
        }
        x = x->next[0];

        if (x && x->key == key) {
            // update existing
            x->val = value;
            return;
        } else {
            int lvl = randomLevel();
            if (lvl > level) {
                for (int i = level; i < lvl; ++i) update[i] = head;
                level = lvl;
            }
            Node* newNode = new Node(lvl, key, value);
            for (int i = 0; i < lvl; ++i) {
                newNode->next[i] = update[i]->next[i];
                update[i]->next[i] = newNode;
            }
        }
    }

    // Erase by key. returns true if erased.
    bool erase(const Key& key) {
        std::unique_lock lock(rwmutex);

        vector<Node*> update(MAX_LEVEL, nullptr);
        Node* x = head;
        for (int i = level - 1; i >= 0; --i) {
            while (x->next[i] && x->next[i]->key < key) x = x->next[i];
            update[i] = x;
        }
        x = x->next[0];
        if (!x || x->key != key) return false;

        for (int i = 0; i < level; ++i) {
            if (update[i]->next[i] != x) break;
            update[i]->next[i] = x->next[i];
        }
        delete x;
        // decrease level if necessary
        while (level > 1 && head->next[level-1] == nullptr) --level;
        return true;
    }

    // Find value by key. Returns optional<Value>
    optional<Value> find(const Key& key) const {
        std::shared_lock lock(rwmutex); // allow concurrent readers
        Node* x = head;
        for (int i = level - 1; i >= 0; --i) {
            while (x->next[i] && x->next[i]->key < key) x = x->next[i];
        }
        x = x->next[0];
        if (x && x->key == key) return x->val;
        return nullopt;
    }

    // Range traversal: collects key-value pairs in [lo, hi] inclusive.
    vector<pair<Key, Value>> rangeQuery(const Key& lo, const Key& hi) const {
        vector<pair<Key, Value>> out;
        std::shared_lock lock(rwmutex);
        Node* x = head;
        for (int i = level - 1; i >= 0; --i)
            while (x->next[i] && x->next[i]->key < lo) x = x->next[i];
        x = x->next[0];
        while (x && x->key <= hi) {
            out.emplace_back(x->key, x->val);
            x = x->next[0];
        }
        return out;
    }

    // For debugging: print first N items
    void dumpFirstN(int N = 50) const {
        std::shared_lock lock(rwmutex);
        Node* x = head->next[0];
        int c = 0;
        while (x && c < N) {
            cout << "[" << x->key << " -> " << x->val << "] ";
            x = x->next[0];
            ++c;
        }
        cout << "\n";
    }
};

// ---------------- DEMO ----------------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    ConcurrentSkipList<int, string> dir(24, 0.5);

    // Prepopulate
    dir.insert(100, "VendorA");
    dir.insert(200, "VendorB");
    dir.insert(150, "VendorC");
    dir.insert(250, "VendorD");

    cout << "Initial directory:\n";
    dir.dumpFirstN();

    // Spawn multiple reader threads and writer threads to demo concurrency
    vector<thread> readers;
    for (int i = 0; i < 4; ++i) {
        readers.emplace_back([&dir, i]() {
            for (int k = 0; k < 10; ++k) {
                auto v = dir.find(150);
                if (v) {
                    // simulate some read processing
                    this_thread::sleep_for(chrono::milliseconds(10));
                }
            }
        });
    }

    vector<thread> writers;
    writers.emplace_back([&dir]() {
        dir.insert(175, "VendorE");
        this_thread::sleep_for(chrono::milliseconds(5));
        dir.erase(100);
    });
    writers.emplace_back([&dir]() {
        dir.insert(125, "VendorF");
        dir.insert(300, "VendorG");
    });

    for (auto &t : readers) t.join();
    for (auto &t : writers) t.join();

    cout << "After concurrent ops:\n";
    dir.dumpFirstN();

    // Range query example
    auto range = dir.rangeQuery(120, 200);
    cout << "Range 120..200 results:\n";
    for (auto &p : range) cout << p.first << " => " << p.second << "\n";

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 23 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 23</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Zone Merge & Permit Management</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Manage dynamic merging of adjacent festival stalls or temporary zones (e.g., combining two low-traffic stalls into one larger stall) and quickly determine which stall group a vendor belongs to.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>When stalls merge for events, or emergency closures partition the area, quickly answer queries like ‚Äúare stall A and stall B currently in the same zone?‚Äù DSU supports union and find checks in near-constant amortized time.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Union-Find (Disjoint Set Union)</div>
                        <div class="info-sub">
                         Zone merges/partitions model is a natural DSU problem ‚Äî very fast, minimal overhead, and maps directly to real operations (merge zone, check zone membership).
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 11 (Sustainable Cities), SDG 3 (Public safety coordination)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre> // zone_dsu.cpp
// C++17 - Disjoint Set Union (Union-Find) for Zone Merge & Permit Management
// Features: union-by-size, path compression, component sizes, group listing

#include <bits/stdc++.h>
using namespace std;

struct DSU {
    int n;
    vector<int> parent;
    vector<int> sz;   // size of component (only accurate at root)
    int components;

    DSU(int n = 0) { init(n); }

    void init(int N) {
        n = N;
        parent.resize(n);
        sz.assign(n, 1);
        for (int i = 0; i < n; ++i) parent[i] = i;
        components = n;
    }

    // Find with path compression
    int find(int x) {
        if (parent[x] == x) return x;
        return parent[x] = find(parent[x]);
    }

    // Union by size. returns true if merged (were distinct).
    bool unite(int a, int b) {
        a = find(a); b = find(b);
        if (a == b) return false;
        // ensure a is the bigger
        if (sz[a] < sz[b]) swap(a,b);
        parent[b] = a;
        sz[a] += sz[b];
        sz[b] = 0; // optional: keep root sizes accurate only at root
        --components;
        return true;
    }

    bool same(int a, int b) { return find(a) == find(b); }

    // size of component containing x
    int component_size(int x) { return sz[find(x)]; }

    int components_count() const { return components; }

    // Build groups: returns map root -> vector of members
    // Complexity: O(n Œ±(n)) (practically linear)
    unordered_map<int, vector<int>> group_all() {
        unordered_map<int, vector<int>> groups;
        groups.reserve(n * 1.1);
        for (int i = 0; i < n; ++i) {
            int r = find(i);
            groups[r].push_back(i);
        }
        return groups;
    }
};

// ---------------- Demo ----------------
// Example: stalls numbered 0..9 (10 stalls). Merge operations simulate combining stalls/zones.
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int stalls = 10;
    DSU dsu(stalls);

    cout << "Initial components: " << dsu.components_count() << "\n";

    // Example merges (merge adjacent stalls when traffic low)
    vector<pair<int,int>> merges = {
        {0,1}, {2,3}, {3,4}, {7,8}
    };
    for (auto &m : merges) {
        bool merged = dsu.unite(m.first, m.second);
        cout << "Merge " << m.first << " & " << m.second << (merged ? " => merged\n" : " => already same\n");
    }

    // Query examples
    cout << "Are stall 2 and 4 in same zone? " << (dsu.same(2,4) ? "Yes\n" : "No\n");
    cout << "Are stall 0 and 4 in same zone? " << (dsu.same(0,4) ? "Yes\n" : "No\n");
    cout << "Size of zone containing stall 3: " << dsu.component_size(3) << "\n";
    cout << "Total active components (zones): " << dsu.components_count() << "\n";

    // If an operator asks "which zone is stall 7 in?" we can get root id
    cout << "Root (representative) of stall 7: " << dsu.find(7) << "\n";

    // Build list of current groups (useful to display merged stall groups / issue permit to group)
    auto groups = dsu.group_all();
    cout << "\nCurrent groups (root -> members):\n";
    for (auto &kv : groups) {
        cout << "Root " << kv.first << " : ";
        for (int x : kv.second) cout << x << " ";
        cout << "(size=" << kv.second.size() << ")\n";
    }

    // Example: trying to split is NOT supported by classic DSU.
    cout << "\nNote: DSU supports fast merges and membership checks but does NOT support splits.\n";
    cout << "If stalls may split frequently, consider a dynamic connectivity data structure or maintain\n"
         << "a higher-level log of operations and rebuild DSU periodically.\n";

    return 0;
}</pre>
                </div>
            </section>
 <!-- ========== CASE 24 ========== -->
            <section class="case">
                <div class="case-header-row">
                    <span>CASE 24</span>
                    <span class="case-pill"> </span>
                </div>
                <div class="case-title">Resilient Routing under Failures</div>

                <div class="case-field">
                    <h3>About the Case</h3>
                    <p>Create a robust backup routing network for utility lines (power or communication) that remains low-cost if individual links fail.</p>
                </div>

                <div class="case-field">
                    <h3>Description of the Business Case</h3>
                    <p>Find a base minimal network (MST) and compute a near-minimal second-best spanning structure (or augment MST with some low-cost extra edges) to allow rerouting after single-edge failures. Prim‚Äôs algorithm finds the MST; then analyze replacement edges.</p>
                </div>

                <div class="case-grid">
                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">‚öôÔ∏è</div>
                            <span>Algorithm Used</span>
                        </div>
                        <div class="info-main">Prim‚Äôs algorithm (MST)</div>
                        <div class="info-sub">
                        builds MST from a node, good for dense graphs and easy to extend to compute replacement edges or k-edge-resilient backbones.
                        </div>
                    </div>

                    <div class="info-card">
                        <div class="info-label-row">
                            <div class="info-icon">üåç</div>
                            <span>SDGs Linked</span>
                        </div>
                        <div class="info-main">SDG 7 (Affordable & Clean Energy) if applied to power lines, SDG 9 (Infrastructure)</div>
                        <div class="info-sub">
                        </div>
                    </div>
                </div>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">C++ Code</span>
                        <button class="copy-btn">Copy Code</button>
                    </div>
<pre>// resilient_mst.cpp
// Compile: g++ -std=c++17 -O2 resilient_mst.cpp -o resilient_mst
// Run: ./resilient_mst < input.txt
//
// Input format:
// N M
// M lines: u v w   (1-based nodes)
// Example below in comments.

#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (1LL<<60);

struct Edge { int u, v; ll w; int idx; };

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    if(!(cin >> N >> M)) {
        cerr << "Expected N M\n";
        return 1;
    }

    vector<Edge> edges;
    edges.reserve(M);
    for(int i=0;i<M;++i){
        int u,v; ll w; cin >> u >> v >> w;
        --u; --v;
        edges.push_back({u,v,w,i});
    }

    // Build adjacency list (for Prim)
    vector<vector<pair<int,ll>>> adj(N);
    for(auto &e: edges){
        adj[e.u].push_back({e.v, e.w});
        adj[e.v].push_back({e.u, e.w});
    }

    // Prim's algorithm to build MST and capture which edges are chosen (by weight + endpoints)
    vector<char> inMST_edge(M, 0); // we'll detect chosen edges by matching endpoints+weight (we'll map later)
    vector<ll> minCost(N, INF);
    vector<int> parentNode(N, -1);
    vector<ll> parentEdgeW(N, 0);
    vector<int> parentEdgeIdx(N, -1);

    // We'll need mapping from (u,v,w) to list of indices; create multimap-like by tuple key
    unordered_multimap<long long, int> edgeKeyToIdx;
    // key = ((ll)min(u,v) << 32) ^ ((ll)max(u,v) << 8) ^ (w & 0xffffffff) -- but to avoid collisions use hashing pair
    // Simpler: store mapping by string key (safe here)
    unordered_map<string, vector<int>> keymap;
    keymap.reserve(M*2);

    auto make_key = [&](int a, int b, ll w)->string{
        if(a>b) swap(a,b);
        return to_string(a) + "#" + to_string(b) + "#" + to_string(w);
    };
    for(auto &e: edges) keymap[make_key(e.u,e.v,e.w)].push_back(e.idx);

    // Prim starting from node 0 (assume connected; will check)
    using pli = pair<ll,int>;
    priority_queue<pli, vector<pli>, greater<pli>> pq;
    minCost[0] = 0;
    pq.push({0,0});

    vector<char> vis(N,0);
    vector<Edge> mstEdges; mstEdges.reserve(N-1);

    while(!pq.empty()){
        auto [c,u] = pq.top(); pq.pop();
        if(vis[u]) continue;
        vis[u] = 1;
        if(parentNode[u] != -1){
            // record MST edge (parentNode[u] -- u)
            mstEdges.push_back({parentNode[u], u, parentEdgeW[u], parentEdgeIdx[u]});
        }
        for(auto &pr : adj[u]){
            int v = pr.first; ll w = pr.second;
            if(!vis[v] && w < minCost[v]){
                minCost[v] = w;
                parentNode[v] = u;
                parentEdgeW[v] = w;
                pq.push({w, v});
            }
        }
    }

    // Check connected
    for(int i=0;i<N;++i) if(!vis[i]) {
        cout << "Graph is disconnected ‚Äî cannot build spanning network.\n";
        return 0;
    }

    // Now we must map each MST edge (u,v,w) to a concrete input edge index.
    // For each recorded MST edge (u,v,w) find a matching input edge index (pop from keymap)
    vector<int> mstEdgeIndex; mstEdgeIndex.reserve(mstEdges.size());
    for(auto &me: mstEdges){
        string k = make_key(me.u, me.v, me.w);
        auto it = keymap.find(k);
        if(it == keymap.end() || it->second.empty()){
            // Should not happen in normal data, but handle gracefully by marking -1
            mstEdgeIndex.push_back(-1);
        } else {
            int idx = it->second.back();
            it->second.pop_back();
            mstEdgeIndex.push_back(idx);
            inMST_edge[idx] = 1;
        }
    }

    // Compute MST total cost
    ll mstCost = 0;
    for(auto &me: mstEdges) mstCost += me.w;

    // Build MST adjacency for tree operations
    vector<vector<pair<int,ll>>> tree(N);
    vector<pair<pair<int,int>,ll>> mstEdgeList; mstEdgeList.reserve(mstEdges.size());
    for(auto &me: mstEdges){
        tree[me.u].push_back({me.v, me.w});
        tree[me.v].push_back({me.u, me.w});
        mstEdgeList.push_back({{me.u, me.v}, me.w});
    }

    // Binary lifting preprocess: parent[k][v] and maxEdge[k][v]
    int LOG = 1;
    while((1<<LOG) <= N) ++LOG;
    vector<vector<int>> up(LOG, vector<int>(N, -1));
    vector<vector<ll>> maxUp(LOG, vector<ll>(N, 0));
    vector<int> depth(N,0);

    // DFS to fill up[0] and depth and maxUp[0]
    function<void(int,int)> dfs = [&](int u, int p){
        for(auto &pr: tree[u]){
            int v = pr.first; ll w = pr.second;
            if(v == p) continue;
            depth[v] = depth[u] + 1;
            up[0][v] = u;
            maxUp[0][v] = w;
            dfs(v, u);
        }
    };
    up[0][0] = -1; maxUp[0][0] = 0; depth[0] = 0;
    dfs(0,-1);

    for(int k=1;k<LOG;++k){
        for(int v=0;v<N;++v){
            if(up[k-1][v] != -1){
                up[k][v] = up[k-1][ up[k-1][v] ];
                maxUp[k][v] = max( maxUp[k-1][v], (up[k-1][v]==-1 ? 0 : maxUp[k-1][ up[k-1][v] ]) );
            } else {
                up[k][v] = -1;
                maxUp[k][v] = maxUp[k-1][v];
            }
        }
    }

    auto maxOnPath = [&](int a, int b)->ll{
        if(a == b) return 0;
        ll res = 0;
        if(depth[a] < depth[b]) swap(a,b);
        int diff = depth[a] - depth[b];
        for(int k=0;k<LOG;++k) if(diff & (1<<k)){
            res = max(res, maxUp[k][a]);
            a = up[k][a];
        }
        if(a==b) return res;
        for(int k=LOG-1;k>=0;--k){
            if(up[k][a] != -1 && up[k][a] != up[k][b]){
                res = max(res, maxUp[k][a]);
                res = max(res, maxUp[k][b]);
                a = up[k][a];
                b = up[k][b];
            }
        }
        // now a and b are children of LCA
        res = max(res, maxUp[0][a]);
        res = max(res, maxUp[0][b]);
        return res;
    };

    // For per-MST-edge replacement tracking:
    // Map each MST edge (u,v,w) to an id we can index (0..N-2)
    // We'll use canonical ordering (min,max) to identify edges.
    unordered_map<long long, int> mstEdgeId; // key -> id
    auto mk_e_key = [&](int a, int b)->long long{
        if(a>b) swap(a,b);
        return ((long long)a<<32) | (unsigned long long)b;
    };
    for(int i=0;i<(int)mstEdges.size();++i){
        int a = mstEdges[i].u, b = mstEdges[i].v;
        mstEdgeId[ mk_e_key(a,b) ] = i;
    }

    // Initialize replacement info
    vector<ll> bestReplacementCostForEdge(mstEdges.size(), INF);
    vector<int> bestReplacementEdgeIdx(mstEdges.size(), -1);

    ll secondBest = INF;
    // For each non-MST edge, compute effect
    for(auto &e: edges){
        if(inMST_edge[e.idx]) continue;
        int u = e.u, v = e.v; ll w = e.w;
        ll maxEdge = maxOnPath(u, v);
        if(maxEdge == 0 && u==v) continue; // self-loop (unlikely)
        // replacement total cost:
        ll candidate = mstCost - maxEdge + w;
        if(candidate > mstCost && candidate < secondBest) secondBest = candidate;
        // find which MST edge(s) on path have weight == maxEdge; any of them could be replaced.
        // To attribute replacement cost per MST edge, we should find specific edge on path with weight == maxEdge.
        // We'll locate the one nearest to u or v: we can climb to find an edge with that weight.
        // We'll implement a helper to find any edge id on path with weight == maxEdge.
        auto findEdgeOnPathWithWeight = [&](int a, int b, ll target)->int{
            // climb a up
            if(depth[a] < depth[b]) swap(a,b);
            int diff = depth[a]-depth[b];
            for(int k=0;k<LOG;++k) if(diff & (1<<k)){
                if(maxUp[k][a] == target){
                    // need to find exact edge lower than or equal to 2^k step - but we can descend
                    // fallback: we will step down by single steps from a to ancestor to pinpoint
                    ;
                }
                a = up[k][a];
            }
            if(a==b) {
                // moved; need to find along original route; fallback below
            }
            // fallback robust approach: walk from original endpoints along path using parent pointers step-by-step (safe for N up to 2e5)
            // We'll do step-by-step from both u and v towards LCA to find the first edge with weight == target.
            // For simplicity and safety, implement step-by-step (O(path length)); amortized still ok for typical sizes.
            // We'll implement outside; here we return -1 as placeholder.
            return -1;
        };
        // Simpler robust approach: find edge(s) on path by walking from u up to LCA and v up to LCA and checking edges.
        // Find LCA:
        int a=u, b=v;
        if(depth[a] < depth[b]) swap(a,b);
        int aa=a, bb=b;
        int diff = depth[a]-depth[b];
        for(int k=0;k<LOG;++k) if(diff & (1<<k)) a = up[k][a];
        if(a != b){
            for(int k=LOG-1;k>=0;--k){
                if(up[k][a] != -1 && up[k][a] != up[k][b]){
                    a = up[k][a];
                    b = up[k][b];
                }
            }
            a = up[0][a];
            b = up[0][b];
        }
        int lca = a;
        // walk from uu->lca
        int uu = uu = u;
        bool found = false;
        // step up from uu until lca
        while(uu != lca){
            int p = up[0][uu];
            ll edgew = maxUp[0][uu];
            if(edgew == maxEdge){
                int id = mstEdgeId[ mk_e_key(uu,p) ];
                if(candidate < bestReplacementCostForEdge[id]){
                    bestReplacementCostForEdge[id] = candidate;
                    bestReplacementEdgeIdx[id] = e.idx;
                }
                found = true;
                // don't break: there may be multiple edges equal to maxEdge; we update all (they all could be replaced)
            }
            uu = p;
        }
        int vv = v;
        while(vv != lca){
            int p = up[0][vv];
            ll edgew = maxUp[0][vv];
            if(edgew == maxEdge){
                int id = mstEdgeId[ mk_e_key(vv,p) ];
                if(candidate < bestReplacementCostForEdge[id]){
                    bestReplacementCostForEdge[id] = candidate;
                    bestReplacementEdgeIdx[id] = e.idx;
                }
                found = true;
            }
            vv = p;
        }
        // if !found, it's okay ‚Äî sometimes due to duplicates weights we may have accounted earlier; continue
    }

    // Output results
    cout << "MST total cost: " << mstCost << "\n";
    cout << "MST edges (u v w) (0-based nodes):\n";
    for(size_t i=0;i<mstEdges.size();++i){
        cout << mstEdges[i].u << " " << mstEdges[i].v << " " << mstEdges[i].w
             << "  (edge_id_input=" << (mstEdgeIndex[i] >=0 ? to_string(mstEdgeIndex[i]) : string("unknown")) << ")\n";
    }
    if(secondBest >= INF) cout << "No second-best spanning tree found (graph may have all equal or no replacing edges).\n";
    else cout << "Second-best MST total cost (best single-edge replacement): " << secondBest << "\n";

    cout << "\nPer-MST-edge cheapest replacement if that edge fails:\n";
    for(size_t i=0;i<mstEdges.size();++i){
        auto &me = mstEdges[i];
        cout << "MST-edge " << i << " (" << me.u << "-" << me.v << " w=" << me.w << "): ";
        if(bestReplacementCostForEdge[i] >= INF) cout << "NO replacement found (cut has no non-MST crossing edges)\n";
        else {
            cout << "replacement total cost = " << bestReplacementCostForEdge[i]
                 << " using input-edge idx " << bestReplacementEdgeIdx[i] << "\n";
        }
    }

    // Suggest backup edges to add: choose, for example, top K best replacements (cheapest increase)
    int K = 3;
    vector<pair<ll,int>> candidates; // (extra cost, inputEdgeIdx)
    for(size_t i=0;i<mstEdges.size();++i){
        if(bestReplacementCostForEdge[i] < INF){
            ll extra = bestReplacementCostForEdge[i] - mstCost;
            candidates.push_back({extra, bestReplacementEdgeIdx[i]});
        }
    }
    sort(candidates.begin(), candidates.end());
    cout << "\nTop " << min((int)candidates.size(), K) << " backup edges to add (cheapest extra cost):\n";
    for(int i=0;i<(int)candidates.size() && i<K; ++i){
        cout << " extra=" << candidates[i].first << "  input_edge_idx=" << candidates[i].second << "\n";
    }

    return 0;
}</pre>
                </div>
            </section>
            <footer>
                KLE TECHNOLOGICAL UNIVERSITY ‚Ä¢ DAA Project 
            </footer>
        </main>
    </div>

    <!-- COPY CODE SCRIPT -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const buttons = document.querySelectorAll('.copy-btn');

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const codeBlock = btn.closest('.code-block');
                    if (!codeBlock) return;
                    const pre = codeBlock.querySelector('pre');
                    if (!pre) return;

                    const text = pre.innerText;

                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            const oldText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = oldText;
                            }, 1200);
                        }).catch(() => {
                            alert('Copy failed. Please copy manually.');
                        });
                    } else {
                        // Fallback for very old browsers
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        document.body.appendChild(textarea);
                        textarea.select();
                        try {
                            document.execCommand('copy');
                            const oldText = btn.textContent;
                            btn.textContent = 'Copied!';
                            setTimeout(() => {
                                btn.textContent = oldText;
                            }, 1200);
                        } catch (e) {
                            alert('Copy failed. Please copy manually.');
                        }
                        document.body.removeChild(textarea);
                    }
                });
            });
        });
    </script>
</body>
</html>
